{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar _require = require(\"../node\"),\n    clone = _require.clone;\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require2 = require(\"../../browser/parser/index\"),\n    parseFragment = _require2.parseFragment;\n\nvar _require3 = require(\"../helpers/namespaces\"),\n    HTML_NS = _require3.HTML_NS;\n\nvar _require4 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require4.domSymbolTree;\n\nvar _require5 = require(\"./boundary-point\"),\n    compareBoundaryPointsPosition = _require5.compareBoundaryPointsPosition;\n\nvar _require6 = require(\"../helpers/node\"),\n    nodeRoot = _require6.nodeRoot,\n    nodeLength = _require6.nodeLength,\n    isInclusiveAncestor = _require6.isInclusiveAncestor;\n\nvar _require7 = require(\"../helpers/create-element\"),\n    createElement = _require7.createElement;\n\nvar AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nvar Range = require(\"../generated/Range\");\n\nvar DocumentFragment = require(\"../generated/DocumentFragment\");\n\nvar _require8 = require(\"../generated/utils\"),\n    implForWrapper = _require8.implForWrapper;\n\nvar RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nvar RangeImpl = /*#__PURE__*/function (_AbstractRangeImpl) {\n  _inherits(RangeImpl, _AbstractRangeImpl);\n\n  var _super = _createSuper(RangeImpl);\n\n  function RangeImpl(globalObject, args, privateData) {\n    var _this;\n\n    _classCallCheck(this, RangeImpl);\n\n    _this = _super.call(this, globalObject, args, privateData);\n    var defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n    var _privateData$start = privateData.start,\n        start = _privateData$start === void 0 ? defaultBoundaryPoint : _privateData$start,\n        _privateData$end = privateData.end,\n        end = _privateData$end === void 0 ? defaultBoundaryPoint : _privateData$end;\n\n    _this._setLiveRangeStart(start.node, start.offset);\n\n    _this._setLiveRangeEnd(end.node, end.offset);\n\n    return _this;\n  } // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n\n\n  _createClass(RangeImpl, [{\n    key: \"setStart\",\n    // https://dom.spec.whatwg.org/#dom-range-setstart\n    value: function setStart(node, offset) {\n      setBoundaryPointStart(this, node, offset);\n    } // https://dom.spec.whatwg.org/#dom-range-setend\n\n  }, {\n    key: \"setEnd\",\n    value: function setEnd(node, offset) {\n      setBoundaryPointEnd(this, node, offset);\n    } // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n\n  }, {\n    key: \"setStartBefore\",\n    value: function setStartBefore(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n    } // https://dom.spec.whatwg.org/#dom-range-setstartafter\n\n  }, {\n    key: \"setStartAfter\",\n    value: function setStartAfter(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n    } // https://dom.spec.whatwg.org/#dom-range-setendbefore\n\n  }, {\n    key: \"setEndBefore\",\n    value: function setEndBefore(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n    } // https://dom.spec.whatwg.org/#dom-range-setendafter\n\n  }, {\n    key: \"setEndAfter\",\n    value: function setEndAfter(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n    } // https://dom.spec.whatwg.org/#dom-range-collapse\n\n  }, {\n    key: \"collapse\",\n    value: function collapse(toStart) {\n      if (toStart) {\n        this._setLiveRangeEnd(this._start.node, this._start.offset);\n      } else {\n        this._setLiveRangeStart(this._end.node, this._end.offset);\n      }\n    } // https://dom.spec.whatwg.org/#dom-range-selectnode\n\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(node) {\n      selectNodeWithinRange(node, this);\n    } // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n\n  }, {\n    key: \"selectNodeContents\",\n    value: function selectNodeContents(node) {\n      if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        throw DOMException.create(this._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n      }\n\n      var length = nodeLength(node);\n\n      this._setLiveRangeStart(node, 0);\n\n      this._setLiveRangeEnd(node, length);\n    } // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n\n  }, {\n    key: \"compareBoundaryPoints\",\n    value: function compareBoundaryPoints(how, sourceRange) {\n      if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {\n        var message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" + \"or 'END_TO_START'.\";\n        throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n      }\n\n      if (this._root !== sourceRange._root) {\n        throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n      }\n\n      var thisPoint;\n      var otherPoint;\n\n      if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n        thisPoint = this._start;\n        otherPoint = sourceRange._start;\n      } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n        thisPoint = this._end;\n        otherPoint = sourceRange._start;\n      } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n        thisPoint = this._end;\n        otherPoint = sourceRange._end;\n      } else {\n        thisPoint = this._start;\n        otherPoint = sourceRange._end;\n      }\n\n      return compareBoundaryPointsPosition(thisPoint, otherPoint);\n    } // https://dom.spec.whatwg.org/#dom-range-deletecontents\n\n  }, {\n    key: \"deleteContents\",\n    value: function deleteContents() {\n      if (this.collapsed) {\n        return;\n      }\n\n      var originalStart = this._start,\n          originalEnd = this._end;\n\n      if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n        originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n        return;\n      }\n\n      var nodesToRemove = [];\n      var currentNode = this._start.node;\n      var endNode = nextNodeDescendant(this._end.node);\n\n      while (currentNode && currentNode !== endNode) {\n        if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {\n          nodesToRemove.push(currentNode);\n        }\n\n        currentNode = domSymbolTree.following(currentNode);\n      }\n\n      var newNode;\n      var newOffset;\n\n      if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n        newNode = originalStart.node;\n        newOffset = originalStart.offset;\n      } else {\n        var referenceNode = originalStart.node;\n\n        while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n          referenceNode = domSymbolTree.parent(referenceNode);\n        }\n\n        newNode = domSymbolTree.parent(referenceNode);\n        newOffset = domSymbolTree.index(referenceNode) + 1;\n      }\n\n      if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n        originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n      }\n\n      for (var _i = 0, _nodesToRemove = nodesToRemove; _i < _nodesToRemove.length; _i++) {\n        var node = _nodesToRemove[_i];\n        var parent = domSymbolTree.parent(node);\n        parent.removeChild(node);\n      }\n\n      if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n        originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n      }\n\n      this._setLiveRangeStart(newNode, newOffset);\n\n      this._setLiveRangeEnd(newNode, newOffset);\n    } // https://dom.spec.whatwg.org/#dom-range-extractcontents\n\n  }, {\n    key: \"extractContents\",\n    value: function extractContents() {\n      return extractRange(this);\n    } // https://dom.spec.whatwg.org/#dom-range-clonecontents\n\n  }, {\n    key: \"cloneContents\",\n    value: function cloneContents() {\n      return cloneRange(this);\n    } // https://dom.spec.whatwg.org/#dom-range-insertnode\n\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node) {\n      insertNodeInRange(node, this);\n    } // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n\n  }, {\n    key: \"surroundContents\",\n    value: function surroundContents(newParent) {\n      var node = this.commonAncestorContainer;\n      var endNode = nextNodeDescendant(node);\n\n      while (node !== endNode) {\n        if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n          throw DOMException.create(this._globalObject, [\"The Range has partially contains a non-Text node.\", \"InvalidStateError\"]);\n        }\n\n        node = domSymbolTree.following(node);\n      }\n\n      if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n      }\n\n      var fragment = extractRange(this);\n\n      while (domSymbolTree.firstChild(newParent)) {\n        newParent.removeChild(domSymbolTree.firstChild(newParent));\n      }\n\n      insertNodeInRange(newParent, this);\n      newParent.appendChild(fragment);\n      selectNodeWithinRange(newParent, this);\n    } // https://dom.spec.whatwg.org/#dom-range-clonerange\n\n  }, {\n    key: \"cloneRange\",\n    value: function cloneRange() {\n      var _start = this._start,\n          _end = this._end,\n          _globalObject = this._globalObject;\n      return Range.createImpl(_globalObject, [], {\n        start: {\n          node: _start.node,\n          offset: _start.offset\n        },\n        end: {\n          node: _end.node,\n          offset: _end.offset\n        }\n      });\n    } // https://dom.spec.whatwg.org/#dom-range-detach\n\n  }, {\n    key: \"detach\",\n    value: function detach() {// Do nothing by spec!\n    } // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n\n  }, {\n    key: \"isPointInRange\",\n    value: function isPointInRange(node, offset) {\n      if (nodeRoot(node) !== this._root) {\n        return false;\n      }\n\n      validateSetBoundaryPoint(node, offset);\n      var bp = {\n        node: node,\n        offset: offset\n      };\n\n      if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {\n        return false;\n      }\n\n      return true;\n    } // https://dom.spec.whatwg.org/#dom-range-comparepoint\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(node, offset) {\n      if (nodeRoot(node) !== this._root) {\n        throw DOMException.create(this._globalObject, [\"The given Node and the Range are not in the same tree.\", \"WrongDocumentError\"]);\n      }\n\n      validateSetBoundaryPoint(node, offset);\n      var bp = {\n        node: node,\n        offset: offset\n      };\n\n      if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n        return -1;\n      } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n        return 1;\n      }\n\n      return 0;\n    } // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n\n  }, {\n    key: \"intersectsNode\",\n    value: function intersectsNode(node) {\n      if (nodeRoot(node) !== this._root) {\n        return false;\n      }\n\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        return true;\n      }\n\n      var offset = domSymbolTree.index(node);\n      return compareBoundaryPointsPosition({\n        node: parent,\n        offset: offset\n      }, this._end) === -1 && compareBoundaryPointsPosition({\n        node: parent,\n        offset: offset + 1\n      }, this._start) === 1;\n    } // https://dom.spec.whatwg.org/#dom-range-stringifier\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var s = \"\";\n      var _start = this._start,\n          _end = this._end;\n\n      if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        return _start.node.data.slice(_start.offset, _end.offset);\n      }\n\n      if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        s += _start.node.data.slice(_start.offset);\n      }\n\n      var currentNode = _start.node;\n      var endNode = nextNodeDescendant(_end.node);\n\n      while (currentNode && currentNode !== endNode) {\n        if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n          s += currentNode.data;\n        }\n\n        currentNode = domSymbolTree.following(currentNode);\n      }\n\n      if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        s += _end.node.data.slice(0, _end.offset);\n      }\n\n      return s;\n    } // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n\n  }, {\n    key: \"createContextualFragment\",\n    value: function createContextualFragment(fragment) {\n      var node = this._start.node;\n      var element;\n\n      switch (node.nodeType) {\n        case NODE_TYPE.DOCUMENT_NODE:\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          element = null;\n          break;\n\n        case NODE_TYPE.ELEMENT_NODE:\n          element = node;\n          break;\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          element = node.parentElement;\n          break;\n\n        default:\n          throw new Error(\"Internal error: Invalid range start node\");\n      }\n\n      if (element === null || element._ownerDocument._parsingMode === \"html\" && element._localName === \"html\" && element._namespaceURI === HTML_NS) {\n        element = createElement(node._ownerDocument, \"body\", HTML_NS);\n      }\n\n      return parseFragment(fragment, element);\n    } // https://dom.spec.whatwg.org/#concept-range-root\n\n  }, {\n    key: \"_setLiveRangeStart\",\n    value: function _setLiveRangeStart(node, offset) {\n      if (this._start && this._start.node !== node) {\n        this._start.node._referencedRanges.delete(this);\n      }\n\n      if (!node._referencedRanges.has(this)) {\n        node._referencedRanges.add(this);\n      }\n\n      this._start = {\n        node: node,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"_setLiveRangeEnd\",\n    value: function _setLiveRangeEnd(node, offset) {\n      if (this._end && this._end.node !== node) {\n        this._end.node._referencedRanges.delete(this);\n      }\n\n      if (!node._referencedRanges.has(this)) {\n        node._referencedRanges.add(this);\n      }\n\n      this._end = {\n        node: node,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"commonAncestorContainer\",\n    get: function get() {\n      var _start = this._start,\n          _end = this._end;\n\n      var _iterator = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(_start.node)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var container = _step.value;\n\n          if (isInclusiveAncestor(container, _end.node)) {\n            return container;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_root\",\n    get: function get() {\n      return nodeRoot(this._start.node);\n    }\n  }]);\n\n  return RangeImpl;\n}(AbstractRangeImpl);\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n} // https://dom.spec.whatwg.org/#concept-range-bp-set\n\n\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\n\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  var bp = {\n    node: node,\n    offset: offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\n\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  var bp = {\n    node: node,\n    offset: offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n} // https://dom.spec.whatwg.org/#concept-range-select\n\n\nfunction selectNodeWithinRange(node, range) {\n  var parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  var index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n\n  range._setLiveRangeEnd(parent, index + 1);\n} // https://dom.spec.whatwg.org/#contained\n\n\nfunction isContained(node, range) {\n  var _start = range._start,\n      _end = range._end;\n  return compareBoundaryPointsPosition({\n    node: node,\n    offset: 0\n  }, _start) === 1 && compareBoundaryPointsPosition({\n    node: node,\n    offset: nodeLength(node)\n  }, _end) === -1;\n} // https://dom.spec.whatwg.org/#partially-contained\n\n\nfunction isPartiallyContained(node, range) {\n  var _start = range._start,\n      _end = range._end;\n  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);\n} // https://dom.spec.whatwg.org/#concept-range-insert\n\n\nfunction insertNodeInRange(node, range) {\n  var _range$_start = range._start,\n      startNode = _range$_start.node,\n      startOffset = _range$_start.offset;\n\n  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  var referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  var parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  var nodeParent = domSymbolTree.parent(node);\n\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  var newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n} // https://dom.spec.whatwg.org/#concept-range-clone\n\n\nfunction cloneRange(range) {\n  var originalStart = range._start,\n      originalEnd = range._end,\n      _globalObject = range._globalObject;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    return fragment;\n  }\n\n  var commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  var firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    var candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  var lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    var _candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(_candidate, range)) {\n        lastPartiallyContainedChild = _candidate;\n      }\n\n      _candidate = domSymbolTree.previousSibling(_candidate);\n    }\n  }\n\n  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {\n    return isContained(node, range);\n  });\n  var hasDoctypeChildren = containedChildren.some(function (node) {\n    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n  });\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned = clone(originalStart.node);\n\n    _cloned._data = _cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(_cloned);\n  } else if (firstPartialContainedChild !== null) {\n    var _cloned2 = clone(firstPartialContainedChild);\n\n    fragment.appendChild(_cloned2);\n    var subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    var subfragment = cloneRange(subrange);\n\n    _cloned2.appendChild(subfragment);\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(containedChildren),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var containedChild = _step2.value;\n\n      var _cloned5 = clone(containedChild, undefined, true);\n\n      fragment.appendChild(_cloned5);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned3 = clone(originalEnd.node);\n\n    _cloned3._data = _cloned3.substringData(0, originalEnd.offset);\n    fragment.appendChild(_cloned3);\n  } else if (lastPartiallyContainedChild !== null) {\n    var _cloned4 = clone(lastPartiallyContainedChild);\n\n    fragment.appendChild(_cloned4);\n\n    var _subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n\n    var _subfragment = cloneRange(_subrange);\n\n    _cloned4.appendChild(_subfragment);\n  }\n\n  return fragment;\n} // https://dom.spec.whatwg.org/#concept-range-extract\n\n\nfunction extractRange(range) {\n  var originalStart = range._start,\n      originalEnd = range._end,\n      _globalObject = range._globalObject;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n    return fragment;\n  }\n\n  var commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  var firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    var candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  var lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    var _candidate2 = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(_candidate2, range)) {\n        lastPartiallyContainedChild = _candidate2;\n      }\n\n      _candidate2 = domSymbolTree.previousSibling(_candidate2);\n    }\n  }\n\n  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {\n    return isContained(node, range);\n  });\n  var hasDoctypeChildren = containedChildren.some(function (node) {\n    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n  });\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  var newNode;\n  var newOffset;\n\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    var referenceNode = originalStart.node;\n\n    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned6 = clone(originalStart.node);\n\n    _cloned6._data = _cloned6.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(_cloned6);\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    var _cloned7 = clone(firstPartialContainedChild);\n\n    fragment.appendChild(_cloned7);\n    var subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    var subfragment = extractRange(subrange);\n\n    _cloned7.appendChild(subfragment);\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(containedChildren),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var containedChild = _step3.value;\n      fragment.appendChild(containedChild);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned8 = clone(originalEnd.node);\n\n    _cloned8._data = _cloned8.substringData(0, originalEnd.offset);\n    fragment.appendChild(_cloned8);\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    var _cloned9 = clone(lastPartiallyContainedChild);\n\n    fragment.appendChild(_cloned9);\n\n    var _subrange2 = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n\n    var _subfragment2 = extractRange(_subrange2);\n\n    _cloned9.appendChild(_subfragment2);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n  setBoundaryPointStart: setBoundaryPointStart,\n  setBoundaryPointEnd: setBoundaryPointEnd\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/jsdom/lib/jsdom/living/range/Range-impl.js"],"names":["DOMException","require","clone","NODE_TYPE","parseFragment","HTML_NS","domSymbolTree","compareBoundaryPointsPosition","nodeRoot","nodeLength","isInclusiveAncestor","createElement","AbstractRangeImpl","implementation","Range","DocumentFragment","implForWrapper","RANGE_COMPARISON_TYPE","START_TO_START","START_TO_END","END_TO_END","END_TO_START","RangeImpl","globalObject","args","privateData","defaultBoundaryPoint","node","_document","offset","start","end","_setLiveRangeStart","_setLiveRangeEnd","setBoundaryPointStart","setBoundaryPointEnd","parent","create","_globalObject","index","toStart","_start","_end","selectNodeWithinRange","nodeType","DOCUMENT_TYPE_NODE","length","how","sourceRange","message","_root","thisPoint","otherPoint","collapsed","originalStart","originalEnd","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","replaceData","nodesToRemove","currentNode","endNode","nextNodeDescendant","isContained","push","following","newNode","newOffset","referenceNode","removeChild","extractRange","cloneRange","insertNodeInRange","newParent","commonAncestorContainer","isPartiallyContained","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","fragment","firstChild","appendChild","createImpl","validateSetBoundaryPoint","bp","s","data","slice","element","ELEMENT_NODE","parentElement","Error","_ownerDocument","_parsingMode","_localName","_namespaceURI","_referencedRanges","delete","has","add","ancestorsIterator","container","nextSibling","range","startNode","startOffset","childrenToArray","_preInsertValidity","splitText","nodeParent","insertBefore","ownerDocument","cloned","_data","substringData","commonAncestor","firstPartialContainedChild","candidate","lastPartiallyContainedChild","lastChild","previousSibling","containedChildren","filter","hasDoctypeChildren","some","subrange","subfragment","containedChild","undefined","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,YAAY,GAAGC,OAAO,CAAC,gCAAD,CAA5B;;eAEkBA,OAAO,CAAC,SAAD,C;IAAjBC,K,YAAAA,K;;AACR,IAAMC,SAAS,GAAGF,OAAO,CAAC,cAAD,CAAzB;;gBAC0BA,OAAO,CAAC,4BAAD,C;IAAzBG,a,aAAAA,a;;gBAEYH,OAAO,CAAC,uBAAD,C;IAAnBI,O,aAAAA,O;;gBACkBJ,OAAO,CAAC,+BAAD,C;IAAzBK,a,aAAAA,a;;gBACkCL,OAAO,CAAC,kBAAD,C;IAAzCM,6B,aAAAA,6B;;gBAC8CN,OAAO,CAAC,iBAAD,C;IAArDO,Q,aAAAA,Q;IAAUC,U,aAAAA,U;IAAYC,mB,aAAAA,mB;;gBACJT,OAAO,CAAC,2BAAD,C;IAAzBU,a,aAAAA,a;;AAER,IAAMC,iBAAiB,GAAGX,OAAO,CAAC,sBAAD,CAAP,CAAgCY,cAA1D;;AAEA,IAAMC,KAAK,GAAGb,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAMc,gBAAgB,GAAGd,OAAO,CAAC,+BAAD,CAAhC;;gBAC2BA,OAAO,CAAC,oBAAD,C;IAA1Be,c,aAAAA,c;;AAER,IAAMC,qBAAqB,GAAG;AAC5BC,EAAAA,cAAc,EAAE,CADY;AAE5BC,EAAAA,YAAY,EAAE,CAFc;AAG5BC,EAAAA,UAAU,EAAE,CAHgB;AAI5BC,EAAAA,YAAY,EAAE;AAJc,CAA9B;;IAOMC,S;;;;;AACJ,qBAAYC,YAAZ,EAA0BC,IAA1B,EAAgCC,WAAhC,EAA6C;AAAA;;AAAA;;AAC3C,8BAAMF,YAAN,EAAoBC,IAApB,EAA0BC,WAA1B;AAEA,QAAMC,oBAAoB,GAAG;AAC3BC,MAAAA,IAAI,EAAEX,cAAc,CAACO,YAAY,CAACK,SAAd,CADO;AAE3BC,MAAAA,MAAM,EAAE;AAFmB,KAA7B;AAH2C,6BAWvCJ,WAXuC,CASzCK,KATyC;AAAA,QASzCA,KATyC,mCASjCJ,oBATiC;AAAA,2BAWvCD,WAXuC,CAUzCM,GAVyC;AAAA,QAUzCA,GAVyC,iCAUnCL,oBAVmC;;AAa3C,UAAKM,kBAAL,CAAwBF,KAAK,CAACH,IAA9B,EAAoCG,KAAK,CAACD,MAA1C;;AACA,UAAKI,gBAAL,CAAsBF,GAAG,CAACJ,IAA1B,EAAgCI,GAAG,CAACF,MAApC;;AAd2C;AAe5C,G,CAED;;;;;AAaA;6BACSF,I,EAAME,M,EAAQ;AACrBK,MAAAA,qBAAqB,CAAC,IAAD,EAAOP,IAAP,EAAaE,MAAb,CAArB;AACD,K,CAED;;;;2BACOF,I,EAAME,M,EAAQ;AACnBM,MAAAA,mBAAmB,CAAC,IAAD,EAAOR,IAAP,EAAaE,MAAb,CAAnB;AACD,K,CAED;;;;mCACeF,I,EAAM;AACnB,UAAMS,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;;AAEA,UAAI,CAACS,MAAL,EAAa;AACX,cAAMpC,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAAC,+BAAD,EAAkC,sBAAlC,CAAxC,CAAN;AACD;;AAEDJ,MAAAA,qBAAqB,CAAC,IAAD,EAAOE,MAAP,EAAe9B,aAAa,CAACiC,KAAd,CAAoBZ,IAApB,CAAf,CAArB;AACD,K,CAED;;;;kCACcA,I,EAAM;AAClB,UAAMS,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;;AAEA,UAAI,CAACS,MAAL,EAAa;AACX,cAAMpC,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAAC,+BAAD,EAAkC,sBAAlC,CAAxC,CAAN;AACD;;AAEDJ,MAAAA,qBAAqB,CAAC,IAAD,EAAOE,MAAP,EAAe9B,aAAa,CAACiC,KAAd,CAAoBZ,IAApB,IAA4B,CAA3C,CAArB;AACD,K,CAED;;;;iCACaA,I,EAAM;AACjB,UAAMS,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;;AAEA,UAAI,CAACS,MAAL,EAAa;AACX,cAAMpC,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAAC,+BAAD,EAAkC,sBAAlC,CAAxC,CAAN;AACD;;AAEDH,MAAAA,mBAAmB,CAAC,IAAD,EAAOC,MAAP,EAAe9B,aAAa,CAACiC,KAAd,CAAoBZ,IAApB,CAAf,CAAnB;AACD,K,CAED;;;;gCACYA,I,EAAM;AAChB,UAAMS,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;;AAEA,UAAI,CAACS,MAAL,EAAa;AACX,cAAMpC,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAAC,+BAAD,EAAkC,sBAAlC,CAAxC,CAAN;AACD;;AAEDH,MAAAA,mBAAmB,CAAC,IAAD,EAAOC,MAAP,EAAe9B,aAAa,CAACiC,KAAd,CAAoBZ,IAApB,IAA4B,CAA3C,CAAnB;AACD,K,CAED;;;;6BACSa,O,EAAS;AAChB,UAAIA,OAAJ,EAAa;AACX,aAAKP,gBAAL,CAAsB,KAAKQ,MAAL,CAAYd,IAAlC,EAAwC,KAAKc,MAAL,CAAYZ,MAApD;AACD,OAFD,MAEO;AACL,aAAKG,kBAAL,CAAwB,KAAKU,IAAL,CAAUf,IAAlC,EAAwC,KAAKe,IAAL,CAAUb,MAAlD;AACD;AACF,K,CAED;;;;+BACWF,I,EAAM;AACfgB,MAAAA,qBAAqB,CAAChB,IAAD,EAAO,IAAP,CAArB;AACD,K,CAED;;;;uCACmBA,I,EAAM;AACvB,UAAIA,IAAI,CAACiB,QAAL,KAAkBzC,SAAS,CAAC0C,kBAAhC,EAAoD;AAClD,cAAM7C,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAC5C,oDAD4C,EAE5C,sBAF4C,CAAxC,CAAN;AAID;;AAED,UAAMQ,MAAM,GAAGrC,UAAU,CAACkB,IAAD,CAAzB;;AAEA,WAAKK,kBAAL,CAAwBL,IAAxB,EAA8B,CAA9B;;AACA,WAAKM,gBAAL,CAAsBN,IAAtB,EAA4BmB,MAA5B;AACD,K,CAED;;;;0CACsBC,G,EAAKC,W,EAAa;AACtC,UACED,GAAG,KAAK9B,qBAAqB,CAACC,cAA9B,IACA6B,GAAG,KAAK9B,qBAAqB,CAACE,YAD9B,IAEA4B,GAAG,KAAK9B,qBAAqB,CAACG,UAF9B,IAGA2B,GAAG,KAAK9B,qBAAqB,CAACI,YAJhC,EAKE;AACA,YAAM4B,OAAO,GAAG,mGACA,oBADhB;AAEA,cAAMjD,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAACW,OAAD,EAAU,mBAAV,CAAxC,CAAN;AACD;;AAED,UAAI,KAAKC,KAAL,KAAeF,WAAW,CAACE,KAA/B,EAAsC;AACpC,cAAMlD,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAAC,0CAAD,EAA6C,oBAA7C,CAAxC,CAAN;AACD;;AAED,UAAIa,SAAJ;AACA,UAAIC,UAAJ;;AACA,UAAIL,GAAG,KAAK9B,qBAAqB,CAACC,cAAlC,EAAkD;AAChDiC,QAAAA,SAAS,GAAG,KAAKV,MAAjB;AACAW,QAAAA,UAAU,GAAGJ,WAAW,CAACP,MAAzB;AACD,OAHD,MAGO,IAAIM,GAAG,KAAK9B,qBAAqB,CAACE,YAAlC,EAAgD;AACrDgC,QAAAA,SAAS,GAAG,KAAKT,IAAjB;AACAU,QAAAA,UAAU,GAAGJ,WAAW,CAACP,MAAzB;AACD,OAHM,MAGA,IAAIM,GAAG,KAAK9B,qBAAqB,CAACG,UAAlC,EAA8C;AACnD+B,QAAAA,SAAS,GAAG,KAAKT,IAAjB;AACAU,QAAAA,UAAU,GAAGJ,WAAW,CAACN,IAAzB;AACD,OAHM,MAGA;AACLS,QAAAA,SAAS,GAAG,KAAKV,MAAjB;AACAW,QAAAA,UAAU,GAAGJ,WAAW,CAACN,IAAzB;AACD;;AAED,aAAOnC,6BAA6B,CAAC4C,SAAD,EAAYC,UAAZ,CAApC;AACD,K,CAED;;;;qCACiB;AACf,UAAI,KAAKC,SAAT,EAAoB;AAClB;AACD;;AAHc,UAKCC,aALD,GAKsC,IALtC,CAKPb,MALO;AAAA,UAKsBc,WALtB,GAKsC,IALtC,CAKgBb,IALhB;;AAOf,UACEY,aAAa,CAAC3B,IAAd,KAAuB4B,WAAW,CAAC5B,IAAnC,KAEE2B,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACqD,SAA1C,IACAF,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACsD,2BAD1C,IAEAH,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACuD,YAJ5C,CADF,EAOE;AACAJ,QAAAA,aAAa,CAAC3B,IAAd,CAAmBgC,WAAnB,CAA+BL,aAAa,CAACzB,MAA7C,EAAqD0B,WAAW,CAAC1B,MAAZ,GAAqByB,aAAa,CAACzB,MAAxF,EAAgG,EAAhG;AACA;AACD;;AAED,UAAM+B,aAAa,GAAG,EAAtB;AACA,UAAIC,WAAW,GAAG,KAAKpB,MAAL,CAAYd,IAA9B;AACA,UAAMmC,OAAO,GAAGC,kBAAkB,CAAC,KAAKrB,IAAL,CAAUf,IAAX,CAAlC;;AACA,aAAOkC,WAAW,IAAIA,WAAW,KAAKC,OAAtC,EAA+C;AAC7C,YACEE,WAAW,CAACH,WAAD,EAAc,IAAd,CAAX,IACA,CAACG,WAAW,CAAC1D,aAAa,CAAC8B,MAAd,CAAqByB,WAArB,CAAD,EAAoC,IAApC,CAFd,EAGE;AACAD,UAAAA,aAAa,CAACK,IAAd,CAAmBJ,WAAnB;AACD;;AAEDA,QAAAA,WAAW,GAAGvD,aAAa,CAAC4D,SAAd,CAAwBL,WAAxB,CAAd;AACD;;AAED,UAAIM,OAAJ;AACA,UAAIC,SAAJ;;AACA,UAAI1D,mBAAmB,CAAC4C,aAAa,CAAC3B,IAAf,EAAqB4B,WAAW,CAAC5B,IAAjC,CAAvB,EAA+D;AAC7DwC,QAAAA,OAAO,GAAGb,aAAa,CAAC3B,IAAxB;AACAyC,QAAAA,SAAS,GAAGd,aAAa,CAACzB,MAA1B;AACD,OAHD,MAGO;AACL,YAAIwC,aAAa,GAAGf,aAAa,CAAC3B,IAAlC;;AAEA,eACE0C,aAAa,IACb,CAAC3D,mBAAmB,CAACJ,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAAD,EAAsCd,WAAW,CAAC5B,IAAlD,CAFtB,EAGE;AACA0C,UAAAA,aAAa,GAAG/D,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAAhB;AACD;;AAEDF,QAAAA,OAAO,GAAG7D,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAAV;AACAD,QAAAA,SAAS,GAAG9D,aAAa,CAACiC,KAAd,CAAoB8B,aAApB,IAAqC,CAAjD;AACD;;AAED,UACEf,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACqD,SAA1C,IACAF,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACsD,2BAD1C,IAEAH,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACuD,YAH5C,EAIE;AACAJ,QAAAA,aAAa,CAAC3B,IAAd,CAAmBgC,WAAnB,CAA+BL,aAAa,CAACzB,MAA7C,EAAqDpB,UAAU,CAAC6C,aAAa,CAAC3B,IAAf,CAAV,GAAiC2B,aAAa,CAACzB,MAApG,EAA4G,EAA5G;AACD;;AAED,wCAAmB+B,aAAnB,oCAAkC;AAA7B,YAAMjC,IAAI,qBAAV;AACH,YAAMS,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;AACAS,QAAAA,MAAM,CAACkC,WAAP,CAAmB3C,IAAnB;AACD;;AAED,UACE4B,WAAW,CAAC5B,IAAZ,CAAiBiB,QAAjB,KAA8BzC,SAAS,CAACqD,SAAxC,IACAD,WAAW,CAAC5B,IAAZ,CAAiBiB,QAAjB,KAA8BzC,SAAS,CAACsD,2BADxC,IAEAF,WAAW,CAAC5B,IAAZ,CAAiBiB,QAAjB,KAA8BzC,SAAS,CAACuD,YAH1C,EAIE;AACAH,QAAAA,WAAW,CAAC5B,IAAZ,CAAiBgC,WAAjB,CAA6B,CAA7B,EAAgCJ,WAAW,CAAC1B,MAA5C,EAAoD,EAApD;AACD;;AAED,WAAKG,kBAAL,CAAwBmC,OAAxB,EAAiCC,SAAjC;;AACA,WAAKnC,gBAAL,CAAsBkC,OAAtB,EAA+BC,SAA/B;AACD,K,CAED;;;;sCACkB;AAChB,aAAOG,YAAY,CAAC,IAAD,CAAnB;AACD,K,CAED;;;;oCACgB;AACd,aAAOC,UAAU,CAAC,IAAD,CAAjB;AACD,K,CAED;;;;+BACW7C,I,EAAM;AACf8C,MAAAA,iBAAiB,CAAC9C,IAAD,EAAO,IAAP,CAAjB;AACD,K,CAED;;;;qCACiB+C,S,EAAW;AAC1B,UAAI/C,IAAI,GAAG,KAAKgD,uBAAhB;AACA,UAAMb,OAAO,GAAGC,kBAAkB,CAACpC,IAAD,CAAlC;;AACA,aAAOA,IAAI,KAAKmC,OAAhB,EAAyB;AACvB,YAAInC,IAAI,CAACiB,QAAL,KAAkBzC,SAAS,CAACqD,SAA5B,IAAyCoB,oBAAoB,CAACjD,IAAD,EAAO,IAAP,CAAjE,EAA+E;AAC7E,gBAAM3B,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAC5C,mDAD4C,EAE5C,mBAF4C,CAAxC,CAAN;AAID;;AAEDX,QAAAA,IAAI,GAAGrB,aAAa,CAAC4D,SAAd,CAAwBvC,IAAxB,CAAP;AACD;;AAED,UACE+C,SAAS,CAAC9B,QAAV,KAAuBzC,SAAS,CAAC0E,aAAjC,IACAH,SAAS,CAAC9B,QAAV,KAAuBzC,SAAS,CAAC0C,kBADjC,IAEA6B,SAAS,CAAC9B,QAAV,KAAuBzC,SAAS,CAAC2E,sBAHnC,EAIE;AACA,cAAM9E,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAAC,uBAAD,EAA0B,sBAA1B,CAAxC,CAAN;AACD;;AAED,UAAMyC,QAAQ,GAAGR,YAAY,CAAC,IAAD,CAA7B;;AAEA,aAAOjE,aAAa,CAAC0E,UAAd,CAAyBN,SAAzB,CAAP,EAA4C;AAC1CA,QAAAA,SAAS,CAACJ,WAAV,CAAsBhE,aAAa,CAAC0E,UAAd,CAAyBN,SAAzB,CAAtB;AACD;;AAEDD,MAAAA,iBAAiB,CAACC,SAAD,EAAY,IAAZ,CAAjB;AAEAA,MAAAA,SAAS,CAACO,WAAV,CAAsBF,QAAtB;AAEApC,MAAAA,qBAAqB,CAAC+B,SAAD,EAAY,IAAZ,CAArB;AACD,K,CAED;;;;iCACa;AAAA,UACHjC,MADG,GAC6B,IAD7B,CACHA,MADG;AAAA,UACKC,IADL,GAC6B,IAD7B,CACKA,IADL;AAAA,UACWJ,aADX,GAC6B,IAD7B,CACWA,aADX;AAGX,aAAOxB,KAAK,CAACoE,UAAN,CAAiB5C,aAAjB,EAAgC,EAAhC,EAAoC;AACzCR,QAAAA,KAAK,EAAE;AAAEH,UAAAA,IAAI,EAAEc,MAAM,CAACd,IAAf;AAAqBE,UAAAA,MAAM,EAAEY,MAAM,CAACZ;AAApC,SADkC;AAEzCE,QAAAA,GAAG,EAAE;AAAEJ,UAAAA,IAAI,EAAEe,IAAI,CAACf,IAAb;AAAmBE,UAAAA,MAAM,EAAEa,IAAI,CAACb;AAAhC;AAFoC,OAApC,CAAP;AAID,K,CAED;;;;6BACS,CACP;AACD,K,CAED;;;;mCACeF,I,EAAME,M,EAAQ;AAC3B,UAAIrB,QAAQ,CAACmB,IAAD,CAAR,KAAmB,KAAKuB,KAA5B,EAAmC;AACjC,eAAO,KAAP;AACD;;AAEDiC,MAAAA,wBAAwB,CAACxD,IAAD,EAAOE,MAAP,CAAxB;AAEA,UAAMuD,EAAE,GAAG;AAAEzD,QAAAA,IAAI,EAAJA,IAAF;AAAQE,QAAAA,MAAM,EAANA;AAAR,OAAX;;AAEA,UACEtB,6BAA6B,CAAC6E,EAAD,EAAK,KAAK3C,MAAV,CAA7B,KAAmD,CAAC,CAApD,IACAlC,6BAA6B,CAAC6E,EAAD,EAAK,KAAK1C,IAAV,CAA7B,KAAiD,CAFnD,EAGE;AACA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD,K,CAED;;;;iCACaf,I,EAAME,M,EAAQ;AACzB,UAAIrB,QAAQ,CAACmB,IAAD,CAAR,KAAmB,KAAKuB,KAA5B,EAAmC;AACjC,cAAMlD,YAAY,CAACqC,MAAb,CAAoB,KAAKC,aAAzB,EAAwC,CAC5C,wDAD4C,EAE5C,oBAF4C,CAAxC,CAAN;AAID;;AAED6C,MAAAA,wBAAwB,CAACxD,IAAD,EAAOE,MAAP,CAAxB;AAEA,UAAMuD,EAAE,GAAG;AAAEzD,QAAAA,IAAI,EAAJA,IAAF;AAAQE,QAAAA,MAAM,EAANA;AAAR,OAAX;;AACA,UAAItB,6BAA6B,CAAC6E,EAAD,EAAK,KAAK3C,MAAV,CAA7B,KAAmD,CAAC,CAAxD,EAA2D;AACzD,eAAO,CAAC,CAAR;AACD,OAFD,MAEO,IAAIlC,6BAA6B,CAAC6E,EAAD,EAAK,KAAK1C,IAAV,CAA7B,KAAiD,CAArD,EAAwD;AAC7D,eAAO,CAAP;AACD;;AAED,aAAO,CAAP;AACD,K,CAED;;;;mCACef,I,EAAM;AACnB,UAAInB,QAAQ,CAACmB,IAAD,CAAR,KAAmB,KAAKuB,KAA5B,EAAmC;AACjC,eAAO,KAAP;AACD;;AAED,UAAMd,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;;AACA,UAAI,CAACS,MAAL,EAAa;AACX,eAAO,IAAP;AACD;;AAED,UAAMP,MAAM,GAAGvB,aAAa,CAACiC,KAAd,CAAoBZ,IAApB,CAAf;AAEA,aACEpB,6BAA6B,CAAC;AAAEoB,QAAAA,IAAI,EAAES,MAAR;AAAgBP,QAAAA,MAAM,EAANA;AAAhB,OAAD,EAA2B,KAAKa,IAAhC,CAA7B,KAAuE,CAAC,CAAxE,IACAnC,6BAA6B,CAAC;AAAEoB,QAAAA,IAAI,EAAES,MAAR;AAAgBP,QAAAA,MAAM,EAAEA,MAAM,GAAG;AAAjC,OAAD,EAAuC,KAAKY,MAA5C,CAA7B,KAAqF,CAFvF;AAID,K,CAED;;;;+BACW;AACT,UAAI4C,CAAC,GAAG,EAAR;AADS,UAED5C,MAFC,GAEgB,IAFhB,CAEDA,MAFC;AAAA,UAEOC,IAFP,GAEgB,IAFhB,CAEOA,IAFP;;AAIT,UAAID,MAAM,CAACd,IAAP,KAAgBe,IAAI,CAACf,IAArB,IAA6Bc,MAAM,CAACd,IAAP,CAAYiB,QAAZ,KAAyBzC,SAAS,CAACqD,SAApE,EAA+E;AAC7E,eAAOf,MAAM,CAACd,IAAP,CAAY2D,IAAZ,CAAiBC,KAAjB,CAAuB9C,MAAM,CAACZ,MAA9B,EAAsCa,IAAI,CAACb,MAA3C,CAAP;AACD;;AAED,UAAIY,MAAM,CAACd,IAAP,CAAYiB,QAAZ,KAAyBzC,SAAS,CAACqD,SAAvC,EAAkD;AAChD6B,QAAAA,CAAC,IAAI5C,MAAM,CAACd,IAAP,CAAY2D,IAAZ,CAAiBC,KAAjB,CAAuB9C,MAAM,CAACZ,MAA9B,CAAL;AACD;;AAED,UAAIgC,WAAW,GAAGpB,MAAM,CAACd,IAAzB;AACA,UAAMmC,OAAO,GAAGC,kBAAkB,CAACrB,IAAI,CAACf,IAAN,CAAlC;;AACA,aAAOkC,WAAW,IAAIA,WAAW,KAAKC,OAAtC,EAA+C;AAC7C,YAAID,WAAW,CAACjB,QAAZ,KAAyBzC,SAAS,CAACqD,SAAnC,IAAgDQ,WAAW,CAACH,WAAD,EAAc,IAAd,CAA/D,EAAoF;AAClFwB,UAAAA,CAAC,IAAIxB,WAAW,CAACyB,IAAjB;AACD;;AAEDzB,QAAAA,WAAW,GAAGvD,aAAa,CAAC4D,SAAd,CAAwBL,WAAxB,CAAd;AACD;;AAED,UAAInB,IAAI,CAACf,IAAL,CAAUiB,QAAV,KAAuBzC,SAAS,CAACqD,SAArC,EAAgD;AAC9C6B,QAAAA,CAAC,IAAI3C,IAAI,CAACf,IAAL,CAAU2D,IAAV,CAAeC,KAAf,CAAqB,CAArB,EAAwB7C,IAAI,CAACb,MAA7B,CAAL;AACD;;AAED,aAAOwD,CAAP;AACD,K,CAED;;;;6CACyBN,Q,EAAU;AAAA,UACzBpD,IADyB,GAChB,KAAKc,MADW,CACzBd,IADyB;AAGjC,UAAI6D,OAAJ;;AACA,cAAQ7D,IAAI,CAACiB,QAAb;AACE,aAAKzC,SAAS,CAAC0E,aAAf;AACA,aAAK1E,SAAS,CAAC2E,sBAAf;AACEU,UAAAA,OAAO,GAAG,IAAV;AACA;;AAEF,aAAKrF,SAAS,CAACsF,YAAf;AACED,UAAAA,OAAO,GAAG7D,IAAV;AACA;;AAEF,aAAKxB,SAAS,CAACqD,SAAf;AACA,aAAKrD,SAAS,CAACuD,YAAf;AACE8B,UAAAA,OAAO,GAAG7D,IAAI,CAAC+D,aAAf;AACA;;AAEF;AACE,gBAAM,IAAIC,KAAJ,CAAU,0CAAV,CAAN;AAhBJ;;AAmBA,UACEH,OAAO,KAAK,IAAZ,IACEA,OAAO,CAACI,cAAR,CAAuBC,YAAvB,KAAwC,MAAxC,IACAL,OAAO,CAACM,UAAR,KAAuB,MADvB,IAEAN,OAAO,CAACO,aAAR,KAA0B1F,OAJ9B,EAME;AACAmF,QAAAA,OAAO,GAAG7E,aAAa,CAACgB,IAAI,CAACiE,cAAN,EAAsB,MAAtB,EAA8BvF,OAA9B,CAAvB;AACD;;AAED,aAAOD,aAAa,CAAC2E,QAAD,EAAWS,OAAX,CAApB;AACD,K,CAED;;;;uCAKmB7D,I,EAAME,M,EAAQ;AAC/B,UAAI,KAAKY,MAAL,IAAe,KAAKA,MAAL,CAAYd,IAAZ,KAAqBA,IAAxC,EAA8C;AAC5C,aAAKc,MAAL,CAAYd,IAAZ,CAAiBqE,iBAAjB,CAAmCC,MAAnC,CAA0C,IAA1C;AACD;;AAED,UAAI,CAACtE,IAAI,CAACqE,iBAAL,CAAuBE,GAAvB,CAA2B,IAA3B,CAAL,EAAuC;AACrCvE,QAAAA,IAAI,CAACqE,iBAAL,CAAuBG,GAAvB,CAA2B,IAA3B;AACD;;AAED,WAAK1D,MAAL,GAAc;AACZd,QAAAA,IAAI,EAAJA,IADY;AAEZE,QAAAA,MAAM,EAANA;AAFY,OAAd;AAID;;;qCAEgBF,I,EAAME,M,EAAQ;AAC7B,UAAI,KAAKa,IAAL,IAAa,KAAKA,IAAL,CAAUf,IAAV,KAAmBA,IAApC,EAA0C;AACxC,aAAKe,IAAL,CAAUf,IAAV,CAAeqE,iBAAf,CAAiCC,MAAjC,CAAwC,IAAxC;AACD;;AAED,UAAI,CAACtE,IAAI,CAACqE,iBAAL,CAAuBE,GAAvB,CAA2B,IAA3B,CAAL,EAAuC;AACrCvE,QAAAA,IAAI,CAACqE,iBAAL,CAAuBG,GAAvB,CAA2B,IAA3B;AACD;;AAED,WAAKzD,IAAL,GAAY;AACVf,QAAAA,IAAI,EAAJA,IADU;AAEVE,QAAAA,MAAM,EAANA;AAFU,OAAZ;AAID;;;wBAnb6B;AAAA,UACpBY,MADoB,GACH,IADG,CACpBA,MADoB;AAAA,UACZC,IADY,GACH,IADG,CACZA,IADY;;AAAA,iDAGJpC,aAAa,CAAC8F,iBAAd,CAAgC3D,MAAM,CAACd,IAAvC,CAHI;AAAA;;AAAA;AAG5B,4DAAsE;AAAA,cAA3D0E,SAA2D;;AACpE,cAAI3F,mBAAmB,CAAC2F,SAAD,EAAY3D,IAAI,CAACf,IAAjB,CAAvB,EAA+C;AAC7C,mBAAO0E,SAAP;AACD;AACF;AAP2B;AAAA;AAAA;AAAA;AAAA;;AAS5B,aAAO,IAAP;AACD;;;wBAyYW;AACV,aAAO7F,QAAQ,CAAC,KAAKiC,MAAL,CAAYd,IAAb,CAAf;AACD;;;;EAxaqBf,iB;;AA0cxB,SAASmD,kBAAT,CAA4BpC,IAA5B,EAAkC;AAChC,SAAOA,IAAI,IAAI,CAACrB,aAAa,CAACgG,WAAd,CAA0B3E,IAA1B,CAAhB,EAAiD;AAC/CA,IAAAA,IAAI,GAAGrB,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAP;AACD;;AAED,MAAI,CAACA,IAAL,EAAW;AACT,WAAO,IAAP;AACD;;AAED,SAAOrB,aAAa,CAACgG,WAAd,CAA0B3E,IAA1B,CAAP;AACD,C,CAED;;;AACA,SAASwD,wBAAT,CAAkCxD,IAAlC,EAAwCE,MAAxC,EAAgD;AAC9C,MAAIF,IAAI,CAACiB,QAAL,KAAkBzC,SAAS,CAAC0C,kBAAhC,EAAoD;AAClD,UAAM7C,YAAY,CAACqC,MAAb,CAAoBV,IAAI,CAACW,aAAzB,EAAwC,CAC5C,oDAD4C,EAE5C,sBAF4C,CAAxC,CAAN;AAID;;AAED,MAAIT,MAAM,GAAGpB,UAAU,CAACkB,IAAD,CAAvB,EAA+B;AAC7B,UAAM3B,YAAY,CAACqC,MAAb,CAAoBV,IAAI,CAACW,aAAzB,EAAwC,CAAC,sBAAD,EAAyB,gBAAzB,CAAxC,CAAN;AACD;AACF;;AACD,SAASJ,qBAAT,CAA+BqE,KAA/B,EAAsC5E,IAAtC,EAA4CE,MAA5C,EAAoD;AAClDsD,EAAAA,wBAAwB,CAACxD,IAAD,EAAOE,MAAP,CAAxB;AAEA,MAAMuD,EAAE,GAAG;AAAEzD,IAAAA,IAAI,EAAJA,IAAF;AAAQE,IAAAA,MAAM,EAANA;AAAR,GAAX;;AACA,MACErB,QAAQ,CAACmB,IAAD,CAAR,KAAmB4E,KAAK,CAACrD,KAAzB,IACA3C,6BAA6B,CAAC6E,EAAD,EAAKmB,KAAK,CAAC7D,IAAX,CAA7B,KAAkD,CAFpD,EAGE;AACA6D,IAAAA,KAAK,CAACtE,gBAAN,CAAuBN,IAAvB,EAA6BE,MAA7B;AACD;;AAED0E,EAAAA,KAAK,CAACvE,kBAAN,CAAyBL,IAAzB,EAA+BE,MAA/B;AACD;;AACD,SAASM,mBAAT,CAA6BoE,KAA7B,EAAoC5E,IAApC,EAA0CE,MAA1C,EAAkD;AAChDsD,EAAAA,wBAAwB,CAACxD,IAAD,EAAOE,MAAP,CAAxB;AAEA,MAAMuD,EAAE,GAAG;AAAEzD,IAAAA,IAAI,EAAJA,IAAF;AAAQE,IAAAA,MAAM,EAANA;AAAR,GAAX;;AACA,MACErB,QAAQ,CAACmB,IAAD,CAAR,KAAmB4E,KAAK,CAACrD,KAAzB,IACA3C,6BAA6B,CAAC6E,EAAD,EAAKmB,KAAK,CAAC9D,MAAX,CAA7B,KAAoD,CAAC,CAFvD,EAGE;AACA8D,IAAAA,KAAK,CAACvE,kBAAN,CAAyBL,IAAzB,EAA+BE,MAA/B;AACD;;AAED0E,EAAAA,KAAK,CAACtE,gBAAN,CAAuBN,IAAvB,EAA6BE,MAA7B;AACD,C,CAED;;;AACA,SAASc,qBAAT,CAA+BhB,IAA/B,EAAqC4E,KAArC,EAA4C;AAC1C,MAAMnE,MAAM,GAAG9B,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAf;;AAEA,MAAI,CAACS,MAAL,EAAa;AACX,UAAMpC,YAAY,CAACqC,MAAb,CAAoBV,IAAI,CAACW,aAAzB,EAAwC,CAAC,+BAAD,EAAkC,sBAAlC,CAAxC,CAAN;AACD;;AAED,MAAMC,KAAK,GAAGjC,aAAa,CAACiC,KAAd,CAAoBZ,IAApB,CAAd;;AAEA4E,EAAAA,KAAK,CAACvE,kBAAN,CAAyBI,MAAzB,EAAiCG,KAAjC;;AACAgE,EAAAA,KAAK,CAACtE,gBAAN,CAAuBG,MAAvB,EAA+BG,KAAK,GAAG,CAAvC;AACD,C,CAED;;;AACA,SAASyB,WAAT,CAAqBrC,IAArB,EAA2B4E,KAA3B,EAAkC;AAAA,MACxB9D,MADwB,GACP8D,KADO,CACxB9D,MADwB;AAAA,MAChBC,IADgB,GACP6D,KADO,CAChB7D,IADgB;AAEhC,SACEnC,6BAA6B,CAAC;AAAEoB,IAAAA,IAAI,EAAJA,IAAF;AAAQE,IAAAA,MAAM,EAAE;AAAhB,GAAD,EAAsBY,MAAtB,CAA7B,KAA+D,CAA/D,IACAlC,6BAA6B,CAAC;AAAEoB,IAAAA,IAAI,EAAJA,IAAF;AAAQE,IAAAA,MAAM,EAAEpB,UAAU,CAACkB,IAAD;AAA1B,GAAD,EAAqCe,IAArC,CAA7B,KAA4E,CAAC,CAF/E;AAID,C,CAED;;;AACA,SAASkC,oBAAT,CAA8BjD,IAA9B,EAAoC4E,KAApC,EAA2C;AAAA,MACjC9D,MADiC,GAChB8D,KADgB,CACjC9D,MADiC;AAAA,MACzBC,IADyB,GAChB6D,KADgB,CACzB7D,IADyB;AAEzC,SACGhC,mBAAmB,CAACiB,IAAD,EAAOc,MAAM,CAACd,IAAd,CAAnB,IAA0C,CAACjB,mBAAmB,CAACiB,IAAD,EAAOe,IAAI,CAACf,IAAZ,CAA/D,IACC,CAACjB,mBAAmB,CAACiB,IAAD,EAAOc,MAAM,CAACd,IAAd,CAApB,IAA2CjB,mBAAmB,CAACiB,IAAD,EAAOe,IAAI,CAACf,IAAZ,CAFjE;AAID,C,CAED;;;AACA,SAAS8C,iBAAT,CAA2B9C,IAA3B,EAAiC4E,KAAjC,EAAwC;AAAA,sBACWA,KAAK,CAAC9D,MADjB;AAAA,MACxB+D,SADwB,iBAC9B7E,IAD8B;AAAA,MACL8E,WADK,iBACb5E,MADa;;AAGtC,MACE2E,SAAS,CAAC5D,QAAV,KAAuBzC,SAAS,CAACsD,2BAAjC,IACA+C,SAAS,CAAC5D,QAAV,KAAuBzC,SAAS,CAACuD,YADjC,IAEC8C,SAAS,CAAC5D,QAAV,KAAuBzC,SAAS,CAACqD,SAAjC,IAA8C,CAAClD,aAAa,CAAC8B,MAAd,CAAqBoE,SAArB,CAFhD,IAGA7E,IAAI,KAAK6E,SAJX,EAKE;AACA,UAAMxG,YAAY,CAACqC,MAAb,CAAoBV,IAAI,CAACW,aAAzB,EAAwC,CAAC,qBAAD,EAAwB,uBAAxB,CAAxC,CAAN;AACD;;AAED,MAAI+B,aAAa,GAAGmC,SAAS,CAAC5D,QAAV,KAAuBzC,SAAS,CAACqD,SAAjC,GAClBgD,SADkB,GAElBlG,aAAa,CAACoG,eAAd,CAA8BF,SAA9B,EAAyCC,WAAzC,KAAyD,IAF3D;AAGA,MAAMrE,MAAM,GAAG,CAACiC,aAAD,GACbmC,SADa,GAEblG,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAFF;;AAIAjC,EAAAA,MAAM,CAACuE,kBAAP,CAA0BhF,IAA1B,EAAgC0C,aAAhC;;AAEA,MAAImC,SAAS,CAAC5D,QAAV,KAAuBzC,SAAS,CAACqD,SAArC,EAAgD;AAC9Ca,IAAAA,aAAa,GAAGmC,SAAS,CAACI,SAAV,CAAoBH,WAApB,CAAhB;AACD;;AAED,MAAI9E,IAAI,KAAK0C,aAAb,EAA4B;AAC1BA,IAAAA,aAAa,GAAG/D,aAAa,CAACgG,WAAd,CAA0BjC,aAA1B,CAAhB;AACD;;AAED,MAAMwC,UAAU,GAAGvG,aAAa,CAAC8B,MAAd,CAAqBT,IAArB,CAAnB;;AACA,MAAIkF,UAAJ,EAAgB;AACdA,IAAAA,UAAU,CAACvC,WAAX,CAAuB3C,IAAvB;AACD;;AAED,MAAIyC,SAAS,GAAG,CAACC,aAAD,GAAiB5D,UAAU,CAAC2B,MAAD,CAA3B,GAAsC9B,aAAa,CAACiC,KAAd,CAAoB8B,aAApB,CAAtD;AACAD,EAAAA,SAAS,IAAIzC,IAAI,CAACiB,QAAL,KAAkBzC,SAAS,CAAC2E,sBAA5B,GAAqDrE,UAAU,CAACkB,IAAD,CAA/D,GAAwE,CAArF;AAEAS,EAAAA,MAAM,CAAC0E,YAAP,CAAoBnF,IAApB,EAA0B0C,aAA1B;;AAEA,MAAIkC,KAAK,CAAClD,SAAV,EAAqB;AACnBkD,IAAAA,KAAK,CAACtE,gBAAN,CAAuBG,MAAvB,EAA+BgC,SAA/B;AACD;AACF,C,CAED;;;AACA,SAASI,UAAT,CAAoB+B,KAApB,EAA2B;AAAA,MACTjD,aADS,GAC2CiD,KAD3C,CACjB9D,MADiB;AAAA,MACYc,WADZ,GAC2CgD,KAD3C,CACM7D,IADN;AAAA,MACyBJ,aADzB,GAC2CiE,KAD3C,CACyBjE,aADzB;AAGzB,MAAMyC,QAAQ,GAAGhE,gBAAgB,CAACmE,UAAjB,CAA4B5C,aAA5B,EAA2C,EAA3C,EAA+C;AAC9DyE,IAAAA,aAAa,EAAEzD,aAAa,CAAC3B,IAAd,CAAmBiE;AAD4B,GAA/C,CAAjB;;AAIA,MAAIW,KAAK,CAAClD,SAAV,EAAqB;AACnB,WAAO0B,QAAP;AACD;;AAED,MACEzB,aAAa,CAAC3B,IAAd,KAAuB4B,WAAW,CAAC5B,IAAnC,KAEE2B,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACqD,SAA1C,IACAF,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACsD,2BAD1C,IAEAH,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACuD,YAJ5C,CADF,EAOE;AACA,QAAMsD,MAAM,GAAG9G,KAAK,CAACoD,aAAa,CAAC3B,IAAf,CAApB;AACAqF,IAAAA,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACE,aAAP,CAAqB5D,aAAa,CAACzB,MAAnC,EAA2C0B,WAAW,CAAC1B,MAAZ,GAAqByB,aAAa,CAACzB,MAA9E,CAAf;AAEAkD,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,MAArB;AAEA,WAAOjC,QAAP;AACD;;AAED,MAAIoC,cAAc,GAAG7D,aAAa,CAAC3B,IAAnC;;AACA,SAAO,CAACjB,mBAAmB,CAACyG,cAAD,EAAiB5D,WAAW,CAAC5B,IAA7B,CAA3B,EAA+D;AAC7DwF,IAAAA,cAAc,GAAG7G,aAAa,CAAC8B,MAAd,CAAqB+E,cAArB,CAAjB;AACD;;AAED,MAAIC,0BAA0B,GAAG,IAAjC;;AACA,MAAI,CAAC1G,mBAAmB,CAAC4C,aAAa,CAAC3B,IAAf,EAAqB4B,WAAW,CAAC5B,IAAjC,CAAxB,EAAgE;AAC9D,QAAI0F,SAAS,GAAG/G,aAAa,CAAC0E,UAAd,CAAyBmC,cAAzB,CAAhB;;AACA,WAAO,CAACC,0BAAR,EAAoC;AAClC,UAAIxC,oBAAoB,CAACyC,SAAD,EAAYd,KAAZ,CAAxB,EAA4C;AAC1Ca,QAAAA,0BAA0B,GAAGC,SAA7B;AACD;;AAEDA,MAAAA,SAAS,GAAG/G,aAAa,CAACgG,WAAd,CAA0Be,SAA1B,CAAZ;AACD;AACF;;AAED,MAAIC,2BAA2B,GAAG,IAAlC;;AACA,MAAI,CAAC5G,mBAAmB,CAAC6C,WAAW,CAAC5B,IAAb,EAAmB2B,aAAa,CAAC3B,IAAjC,CAAxB,EAAgE;AAC9D,QAAI0F,UAAS,GAAG/G,aAAa,CAACiH,SAAd,CAAwBJ,cAAxB,CAAhB;;AACA,WAAO,CAACG,2BAAR,EAAqC;AACnC,UAAI1C,oBAAoB,CAACyC,UAAD,EAAYd,KAAZ,CAAxB,EAA4C;AAC1Ce,QAAAA,2BAA2B,GAAGD,UAA9B;AACD;;AAEDA,MAAAA,UAAS,GAAG/G,aAAa,CAACkH,eAAd,CAA8BH,UAA9B,CAAZ;AACD;AACF;;AAED,MAAMI,iBAAiB,GAAGnH,aAAa,CAACoG,eAAd,CAA8BS,cAA9B,EACvBO,MADuB,CAChB,UAAA/F,IAAI;AAAA,WAAIqC,WAAW,CAACrC,IAAD,EAAO4E,KAAP,CAAf;AAAA,GADY,CAA1B;AAGA,MAAMoB,kBAAkB,GAAGF,iBAAiB,CAACG,IAAlB,CAAuB,UAAAjG,IAAI;AAAA,WAAIA,IAAI,CAACiB,QAAL,KAAkBzC,SAAS,CAAC0C,kBAAhC;AAAA,GAA3B,CAA3B;;AACA,MAAI8E,kBAAJ,EAAwB;AACtB,UAAM3H,YAAY,CAACqC,MAAb,CAAoBkE,KAAK,CAACjE,aAA1B,EAAyC,CAAC,gCAAD,EAAmC,uBAAnC,CAAzC,CAAN;AACD;;AAED,MACE8E,0BAA0B,KAAK,IAA/B,KAEEA,0BAA0B,CAACxE,QAA3B,KAAwCzC,SAAS,CAACqD,SAAlD,IACA4D,0BAA0B,CAACxE,QAA3B,KAAwCzC,SAAS,CAACsD,2BADlD,IAEA2D,0BAA0B,CAACxE,QAA3B,KAAwCzC,SAAS,CAACuD,YAJpD,CADF,EAOE;AACA,QAAMsD,OAAM,GAAG9G,KAAK,CAACoD,aAAa,CAAC3B,IAAf,CAApB;;AACAqF,IAAAA,OAAM,CAACC,KAAP,GAAeD,OAAM,CAACE,aAAP,CAAqB5D,aAAa,CAACzB,MAAnC,EAA2CpB,UAAU,CAAC6C,aAAa,CAAC3B,IAAf,CAAV,GAAiC2B,aAAa,CAACzB,MAA1F,CAAf;AAEAkD,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,OAArB;AACD,GAZD,MAYO,IAAII,0BAA0B,KAAK,IAAnC,EAAyC;AAC9C,QAAMJ,QAAM,GAAG9G,KAAK,CAACkH,0BAAD,CAApB;;AACArC,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;AAEA,QAAMa,QAAQ,GAAG/G,KAAK,CAACoE,UAAN,CAAiB5C,aAAjB,EAAgC,EAAhC,EAAoC;AACnDR,MAAAA,KAAK,EAAE;AAAEH,QAAAA,IAAI,EAAE2B,aAAa,CAAC3B,IAAtB;AAA4BE,QAAAA,MAAM,EAAEyB,aAAa,CAACzB;AAAlD,OAD4C;AAEnDE,MAAAA,GAAG,EAAE;AAAEJ,QAAAA,IAAI,EAAEyF,0BAAR;AAAoCvF,QAAAA,MAAM,EAAEpB,UAAU,CAAC2G,0BAAD;AAAtD;AAF8C,KAApC,CAAjB;AAKA,QAAMU,WAAW,GAAGtD,UAAU,CAACqD,QAAD,CAA9B;;AACAb,IAAAA,QAAM,CAAC/B,WAAP,CAAmB6C,WAAnB;AACD;;AAvFwB,8CAyFIL,iBAzFJ;AAAA;;AAAA;AAyFzB,2DAAgD;AAAA,UAArCM,cAAqC;;AAC9C,UAAMf,QAAM,GAAG9G,KAAK,CAAC6H,cAAD,EAAiBC,SAAjB,EAA4B,IAA5B,CAApB;;AACAjD,MAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;AACD;AA5FwB;AAAA;AAAA;AAAA;AAAA;;AA8FzB,MACEM,2BAA2B,KAAK,IAAhC,KAEEA,2BAA2B,CAAC1E,QAA5B,KAAyCzC,SAAS,CAACqD,SAAnD,IACA8D,2BAA2B,CAAC1E,QAA5B,KAAyCzC,SAAS,CAACsD,2BADnD,IAEA6D,2BAA2B,CAAC1E,QAA5B,KAAyCzC,SAAS,CAACuD,YAJrD,CADF,EAOE;AACA,QAAMsD,QAAM,GAAG9G,KAAK,CAACqD,WAAW,CAAC5B,IAAb,CAApB;;AACAqF,IAAAA,QAAM,CAACC,KAAP,GAAeD,QAAM,CAACE,aAAP,CAAqB,CAArB,EAAwB3D,WAAW,CAAC1B,MAApC,CAAf;AAEAkD,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;AACD,GAZD,MAYO,IAAIM,2BAA2B,KAAK,IAApC,EAA0C;AAC/C,QAAMN,QAAM,GAAG9G,KAAK,CAACoH,2BAAD,CAApB;;AACAvC,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;;AAEA,QAAMa,SAAQ,GAAG/G,KAAK,CAACoE,UAAN,CAAiB5C,aAAjB,EAAgC,EAAhC,EAAoC;AACnDR,MAAAA,KAAK,EAAE;AAAEH,QAAAA,IAAI,EAAE2F,2BAAR;AAAqCzF,QAAAA,MAAM,EAAE;AAA7C,OAD4C;AAEnDE,MAAAA,GAAG,EAAE;AAAEJ,QAAAA,IAAI,EAAE4B,WAAW,CAAC5B,IAApB;AAA0BE,QAAAA,MAAM,EAAE0B,WAAW,CAAC1B;AAA9C;AAF8C,KAApC,CAAjB;;AAKA,QAAMiG,YAAW,GAAGtD,UAAU,CAACqD,SAAD,CAA9B;;AACAb,IAAAA,QAAM,CAAC/B,WAAP,CAAmB6C,YAAnB;AACD;;AAED,SAAO/C,QAAP;AACD,C,CAED;;;AACA,SAASR,YAAT,CAAsBgC,KAAtB,EAA6B;AAAA,MACXjD,aADW,GACyCiD,KADzC,CACnB9D,MADmB;AAAA,MACUc,WADV,GACyCgD,KADzC,CACI7D,IADJ;AAAA,MACuBJ,aADvB,GACyCiE,KADzC,CACuBjE,aADvB;AAG3B,MAAMyC,QAAQ,GAAGhE,gBAAgB,CAACmE,UAAjB,CAA4B5C,aAA5B,EAA2C,EAA3C,EAA+C;AAC9DyE,IAAAA,aAAa,EAAEzD,aAAa,CAAC3B,IAAd,CAAmBiE;AAD4B,GAA/C,CAAjB;;AAIA,MAAIW,KAAK,CAAClD,SAAV,EAAqB;AACnB,WAAO0B,QAAP;AACD;;AAED,MACEzB,aAAa,CAAC3B,IAAd,KAAuB4B,WAAW,CAAC5B,IAAnC,KAEE2B,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACqD,SAA1C,IACAF,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACsD,2BAD1C,IAEAH,aAAa,CAAC3B,IAAd,CAAmBiB,QAAnB,KAAgCzC,SAAS,CAACuD,YAJ5C,CADF,EAOE;AACA,QAAMsD,MAAM,GAAG9G,KAAK,CAACoD,aAAa,CAAC3B,IAAf,CAApB;AACAqF,IAAAA,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACE,aAAP,CAAqB5D,aAAa,CAACzB,MAAnC,EAA2C0B,WAAW,CAAC1B,MAAZ,GAAqByB,aAAa,CAACzB,MAA9E,CAAf;AAEAkD,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,MAArB;AACA1D,IAAAA,aAAa,CAAC3B,IAAd,CAAmBgC,WAAnB,CAA+BL,aAAa,CAACzB,MAA7C,EAAqD0B,WAAW,CAAC1B,MAAZ,GAAqByB,aAAa,CAACzB,MAAxF,EAAgG,EAAhG;AAEA,WAAOkD,QAAP;AACD;;AAED,MAAIoC,cAAc,GAAG7D,aAAa,CAAC3B,IAAnC;;AACA,SAAO,CAACjB,mBAAmB,CAACyG,cAAD,EAAiB5D,WAAW,CAAC5B,IAA7B,CAA3B,EAA+D;AAC7DwF,IAAAA,cAAc,GAAG7G,aAAa,CAAC8B,MAAd,CAAqB+E,cAArB,CAAjB;AACD;;AAED,MAAIC,0BAA0B,GAAG,IAAjC;;AACA,MAAI,CAAC1G,mBAAmB,CAAC4C,aAAa,CAAC3B,IAAf,EAAqB4B,WAAW,CAAC5B,IAAjC,CAAxB,EAAgE;AAC9D,QAAI0F,SAAS,GAAG/G,aAAa,CAAC0E,UAAd,CAAyBmC,cAAzB,CAAhB;;AACA,WAAO,CAACC,0BAAR,EAAoC;AAClC,UAAIxC,oBAAoB,CAACyC,SAAD,EAAYd,KAAZ,CAAxB,EAA4C;AAC1Ca,QAAAA,0BAA0B,GAAGC,SAA7B;AACD;;AAEDA,MAAAA,SAAS,GAAG/G,aAAa,CAACgG,WAAd,CAA0Be,SAA1B,CAAZ;AACD;AACF;;AAED,MAAIC,2BAA2B,GAAG,IAAlC;;AACA,MAAI,CAAC5G,mBAAmB,CAAC6C,WAAW,CAAC5B,IAAb,EAAmB2B,aAAa,CAAC3B,IAAjC,CAAxB,EAAgE;AAC9D,QAAI0F,WAAS,GAAG/G,aAAa,CAACiH,SAAd,CAAwBJ,cAAxB,CAAhB;;AACA,WAAO,CAACG,2BAAR,EAAqC;AACnC,UAAI1C,oBAAoB,CAACyC,WAAD,EAAYd,KAAZ,CAAxB,EAA4C;AAC1Ce,QAAAA,2BAA2B,GAAGD,WAA9B;AACD;;AAEDA,MAAAA,WAAS,GAAG/G,aAAa,CAACkH,eAAd,CAA8BH,WAA9B,CAAZ;AACD;AACF;;AAED,MAAMI,iBAAiB,GAAGnH,aAAa,CAACoG,eAAd,CAA8BS,cAA9B,EACvBO,MADuB,CAChB,UAAA/F,IAAI;AAAA,WAAIqC,WAAW,CAACrC,IAAD,EAAO4E,KAAP,CAAf;AAAA,GADY,CAA1B;AAGA,MAAMoB,kBAAkB,GAAGF,iBAAiB,CAACG,IAAlB,CAAuB,UAAAjG,IAAI;AAAA,WAAIA,IAAI,CAACiB,QAAL,KAAkBzC,SAAS,CAAC0C,kBAAhC;AAAA,GAA3B,CAA3B;;AACA,MAAI8E,kBAAJ,EAAwB;AACtB,UAAM3H,YAAY,CAACqC,MAAb,CAAoBkE,KAAK,CAACjE,aAA1B,EAAyC,CAAC,gCAAD,EAAmC,uBAAnC,CAAzC,CAAN;AACD;;AAED,MAAI6B,OAAJ;AACA,MAAIC,SAAJ;;AACA,MAAI1D,mBAAmB,CAAC4C,aAAa,CAAC3B,IAAf,EAAqB4B,WAAW,CAAC5B,IAAjC,CAAvB,EAA+D;AAC7DwC,IAAAA,OAAO,GAAGb,aAAa,CAAC3B,IAAxB;AACAyC,IAAAA,SAAS,GAAGd,aAAa,CAACzB,MAA1B;AACD,GAHD,MAGO;AACL,QAAIwC,aAAa,GAAGf,aAAa,CAAC3B,IAAlC;;AAEA,WACE0C,aAAa,IACb,CAAC3D,mBAAmB,CAACJ,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAAD,EAAsCd,WAAW,CAAC5B,IAAlD,CAFtB,EAGE;AACA0C,MAAAA,aAAa,GAAG/D,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAAhB;AACD;;AAEDF,IAAAA,OAAO,GAAG7D,aAAa,CAAC8B,MAAd,CAAqBiC,aAArB,CAAV;AACAD,IAAAA,SAAS,GAAG9D,aAAa,CAACiC,KAAd,CAAoB8B,aAApB,IAAqC,CAAjD;AACD;;AAED,MACE+C,0BAA0B,KAAK,IAA/B,KAEEA,0BAA0B,CAACxE,QAA3B,KAAwCzC,SAAS,CAACqD,SAAlD,IACA4D,0BAA0B,CAACxE,QAA3B,KAAwCzC,SAAS,CAACsD,2BADlD,IAEA2D,0BAA0B,CAACxE,QAA3B,KAAwCzC,SAAS,CAACuD,YAJpD,CADF,EAOE;AACA,QAAMsD,QAAM,GAAG9G,KAAK,CAACoD,aAAa,CAAC3B,IAAf,CAApB;;AACAqF,IAAAA,QAAM,CAACC,KAAP,GAAeD,QAAM,CAACE,aAAP,CAAqB5D,aAAa,CAACzB,MAAnC,EAA2CpB,UAAU,CAAC6C,aAAa,CAAC3B,IAAf,CAAV,GAAiC2B,aAAa,CAACzB,MAA1F,CAAf;AAEAkD,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;AAEA1D,IAAAA,aAAa,CAAC3B,IAAd,CAAmBgC,WAAnB,CAA+BL,aAAa,CAACzB,MAA7C,EAAqDpB,UAAU,CAAC6C,aAAa,CAAC3B,IAAf,CAAV,GAAiC2B,aAAa,CAACzB,MAApG,EAA4G,EAA5G;AACD,GAdD,MAcO,IAAIuF,0BAA0B,KAAK,IAAnC,EAAyC;AAC9C,QAAMJ,QAAM,GAAG9G,KAAK,CAACkH,0BAAD,CAApB;;AACArC,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;AAEA,QAAMa,QAAQ,GAAG/G,KAAK,CAACoE,UAAN,CAAiB5C,aAAjB,EAAgC,EAAhC,EAAoC;AACnDR,MAAAA,KAAK,EAAE;AAAEH,QAAAA,IAAI,EAAE2B,aAAa,CAAC3B,IAAtB;AAA4BE,QAAAA,MAAM,EAAEyB,aAAa,CAACzB;AAAlD,OAD4C;AAEnDE,MAAAA,GAAG,EAAE;AAAEJ,QAAAA,IAAI,EAAEyF,0BAAR;AAAoCvF,QAAAA,MAAM,EAAEpB,UAAU,CAAC2G,0BAAD;AAAtD;AAF8C,KAApC,CAAjB;AAKA,QAAMU,WAAW,GAAGvD,YAAY,CAACsD,QAAD,CAAhC;;AACAb,IAAAA,QAAM,CAAC/B,WAAP,CAAmB6C,WAAnB;AACD;;AA7G0B,8CA+GEL,iBA/GF;AAAA;;AAAA;AA+G3B,2DAAgD;AAAA,UAArCM,cAAqC;AAC9ChD,MAAAA,QAAQ,CAACE,WAAT,CAAqB8C,cAArB;AACD;AAjH0B;AAAA;AAAA;AAAA;AAAA;;AAmH3B,MACET,2BAA2B,KAAK,IAAhC,KAEEA,2BAA2B,CAAC1E,QAA5B,KAAyCzC,SAAS,CAACqD,SAAnD,IACA8D,2BAA2B,CAAC1E,QAA5B,KAAyCzC,SAAS,CAACsD,2BADnD,IAEA6D,2BAA2B,CAAC1E,QAA5B,KAAyCzC,SAAS,CAACuD,YAJrD,CADF,EAOE;AACA,QAAMsD,QAAM,GAAG9G,KAAK,CAACqD,WAAW,CAAC5B,IAAb,CAApB;;AACAqF,IAAAA,QAAM,CAACC,KAAP,GAAeD,QAAM,CAACE,aAAP,CAAqB,CAArB,EAAwB3D,WAAW,CAAC1B,MAApC,CAAf;AAEAkD,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;AAEAzD,IAAAA,WAAW,CAAC5B,IAAZ,CAAiBgC,WAAjB,CAA6B,CAA7B,EAAgCJ,WAAW,CAAC1B,MAA5C,EAAoD,EAApD;AACD,GAdD,MAcO,IAAIyF,2BAA2B,KAAK,IAApC,EAA0C;AAC/C,QAAMN,QAAM,GAAG9G,KAAK,CAACoH,2BAAD,CAApB;;AACAvC,IAAAA,QAAQ,CAACE,WAAT,CAAqB+B,QAArB;;AAEA,QAAMa,UAAQ,GAAG/G,KAAK,CAACoE,UAAN,CAAiB5C,aAAjB,EAAgC,EAAhC,EAAoC;AACnDR,MAAAA,KAAK,EAAE;AAAEH,QAAAA,IAAI,EAAE2F,2BAAR;AAAqCzF,QAAAA,MAAM,EAAE;AAA7C,OAD4C;AAEnDE,MAAAA,GAAG,EAAE;AAAEJ,QAAAA,IAAI,EAAE4B,WAAW,CAAC5B,IAApB;AAA0BE,QAAAA,MAAM,EAAE0B,WAAW,CAAC1B;AAA9C;AAF8C,KAApC,CAAjB;;AAKA,QAAMiG,aAAW,GAAGvD,YAAY,CAACsD,UAAD,CAAhC;;AACAb,IAAAA,QAAM,CAAC/B,WAAP,CAAmB6C,aAAnB;AACD;;AAEDvB,EAAAA,KAAK,CAACvE,kBAAN,CAAyBmC,OAAzB,EAAkCC,SAAlC;;AACAmC,EAAAA,KAAK,CAACtE,gBAAN,CAAuBkC,OAAvB,EAAgCC,SAAhC;;AAEA,SAAOW,QAAP;AACD;;AAEDkD,MAAM,CAACC,OAAP,GAAiB;AACfrH,EAAAA,cAAc,EAAES,SADD;AAGfY,EAAAA,qBAAqB,EAArBA,qBAHe;AAIfC,EAAAA,mBAAmB,EAAnBA;AAJe,CAAjB","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst { clone } = require(\"../node\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { parseFragment } = require(\"../../browser/parser/index\");\n\nconst { HTML_NS } = require(\"../helpers/namespaces\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { compareBoundaryPointsPosition } = require(\"./boundary-point\");\nconst { nodeRoot, nodeLength, isInclusiveAncestor } = require(\"../helpers/node\");\nconst { createElement } = require(\"../helpers/create-element\");\n\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nconst Range = require(\"../generated/Range\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst { implForWrapper } = require(\"../generated/utils\");\n\nconst RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nclass RangeImpl extends AbstractRangeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    const defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n\n    const {\n      start = defaultBoundaryPoint,\n      end = defaultBoundaryPoint\n    } = privateData;\n\n    this._setLiveRangeStart(start.node, start.offset);\n    this._setLiveRangeEnd(end.node, end.offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n  get commonAncestorContainer() {\n    const { _start, _end } = this;\n\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\n      if (isInclusiveAncestor(container, _end.node)) {\n        return container;\n      }\n    }\n\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstart\n  setStart(node, offset) {\n    setBoundaryPointStart(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setend\n  setEnd(node, offset) {\n    setBoundaryPointEnd(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n  setStartBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartafter\n  setStartAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendbefore\n  setEndBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendafter\n  setEndAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-collapse\n  collapse(toStart) {\n    if (toStart) {\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\n    } else {\n      this._setLiveRangeStart(this._end.node, this._end.offset);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnode\n  selectNode(node) {\n    selectNodeWithinRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n  selectNodeContents(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"DocumentType Node can't be used as boundary point.\",\n        \"InvalidNodeTypeError\"\n      ]);\n    }\n\n    const length = nodeLength(node);\n\n    this._setLiveRangeStart(node, 0);\n    this._setLiveRangeEnd(node, length);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n  compareBoundaryPoints(how, sourceRange) {\n    if (\n      how !== RANGE_COMPARISON_TYPE.START_TO_START &&\n      how !== RANGE_COMPARISON_TYPE.START_TO_END &&\n      how !== RANGE_COMPARISON_TYPE.END_TO_END &&\n      how !== RANGE_COMPARISON_TYPE.END_TO_START\n    ) {\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" +\n                      \"or 'END_TO_START'.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (this._root !== sourceRange._root) {\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    let thisPoint;\n    let otherPoint;\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n      thisPoint = this._start;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._end;\n    } else {\n      thisPoint = this._start;\n      otherPoint = sourceRange._end;\n    }\n\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-deletecontents\n  deleteContents() {\n    if (this.collapsed) {\n      return;\n    }\n\n    const { _start: originalStart, _end: originalEnd } = this;\n\n    if (\n      originalStart.node === originalEnd.node &&\n      (\n        originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n        originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n        originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n      )\n    ) {\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n      return;\n    }\n\n    const nodesToRemove = [];\n    let currentNode = this._start.node;\n    const endNode = nextNodeDescendant(this._end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (\n        isContained(currentNode, this) &&\n        !isContained(domSymbolTree.parent(currentNode), this)\n      ) {\n        nodesToRemove.push(currentNode);\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    let newNode;\n    let newOffset;\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n      newNode = originalStart.node;\n      newOffset = originalStart.offset;\n    } else {\n      let referenceNode = originalStart.node;\n\n      while (\n        referenceNode &&\n        !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\n      ) {\n        referenceNode = domSymbolTree.parent(referenceNode);\n      }\n\n      newNode = domSymbolTree.parent(referenceNode);\n      newOffset = domSymbolTree.index(referenceNode) + 1;\n    }\n\n    if (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    ) {\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n    }\n\n    for (const node of nodesToRemove) {\n      const parent = domSymbolTree.parent(node);\n      parent.removeChild(node);\n    }\n\n    if (\n      originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE\n    ) {\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n    }\n\n    this._setLiveRangeStart(newNode, newOffset);\n    this._setLiveRangeEnd(newNode, newOffset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-extractcontents\n  extractContents() {\n    return extractRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonecontents\n  cloneContents() {\n    return cloneRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-insertnode\n  insertNode(node) {\n    insertNodeInRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n  surroundContents(newParent) {\n    let node = this.commonAncestorContainer;\n    const endNode = nextNodeDescendant(node);\n    while (node !== endNode) {\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n        throw DOMException.create(this._globalObject, [\n          \"The Range has partially contains a non-Text node.\",\n          \"InvalidStateError\"\n        ]);\n      }\n\n      node = domSymbolTree.following(node);\n    }\n\n    if (\n      newParent.nodeType === NODE_TYPE.DOCUMENT_NODE ||\n      newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE ||\n      newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const fragment = extractRange(this);\n\n    while (domSymbolTree.firstChild(newParent)) {\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\n    }\n\n    insertNodeInRange(newParent, this);\n\n    newParent.appendChild(fragment);\n\n    selectNodeWithinRange(newParent, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonerange\n  cloneRange() {\n    const { _start, _end, _globalObject } = this;\n\n    return Range.createImpl(_globalObject, [], {\n      start: { node: _start.node, offset: _start.offset },\n      end: { node: _end.node, offset: _end.offset }\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-detach\n  detach() {\n    // Do nothing by spec!\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n  isPointInRange(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    validateSetBoundaryPoint(node, offset);\n\n    const bp = { node, offset };\n\n    if (\n      compareBoundaryPointsPosition(bp, this._start) === -1 ||\n      compareBoundaryPointsPosition(bp, this._end) === 1\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-comparepoint\n  comparePoint(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      throw DOMException.create(this._globalObject, [\n        \"The given Node and the Range are not in the same tree.\",\n        \"WrongDocumentError\"\n      ]);\n    }\n\n    validateSetBoundaryPoint(node, offset);\n\n    const bp = { node, offset };\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n      return -1;\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n  intersectsNode(node) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      return true;\n    }\n\n    const offset = domSymbolTree.index(node);\n\n    return (\n      compareBoundaryPointsPosition({ node: parent, offset }, this._end) === -1 &&\n      compareBoundaryPointsPosition({ node: parent, offset: offset + 1 }, this._start) === 1\n    );\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-stringifier\n  toString() {\n    let s = \"\";\n    const { _start, _end } = this;\n\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      return _start.node.data.slice(_start.offset, _end.offset);\n    }\n\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _start.node.data.slice(_start.offset);\n    }\n\n    let currentNode = _start.node;\n    const endNode = nextNodeDescendant(_end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n        s += currentNode.data;\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _end.node.data.slice(0, _end.offset);\n    }\n\n    return s;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n  createContextualFragment(fragment) {\n    const { node } = this._start;\n\n    let element;\n    switch (node.nodeType) {\n      case NODE_TYPE.DOCUMENT_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        element = null;\n        break;\n\n      case NODE_TYPE.ELEMENT_NODE:\n        element = node;\n        break;\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        element = node.parentElement;\n        break;\n\n      default:\n        throw new Error(\"Internal error: Invalid range start node\");\n    }\n\n    if (\n      element === null || (\n        element._ownerDocument._parsingMode === \"html\" &&\n        element._localName === \"html\" &&\n        element._namespaceURI === HTML_NS\n      )\n    ) {\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\n    }\n\n    return parseFragment(fragment, element);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-range-root\n  get _root() {\n    return nodeRoot(this._start.node);\n  }\n\n  _setLiveRangeStart(node, offset) {\n    if (this._start && this._start.node !== node) {\n      this._start.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._start = {\n      node,\n      offset\n    };\n  }\n\n  _setLiveRangeEnd(node, offset) {\n    if (this._end && this._end.node !== node) {\n      this._end.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._end = {\n      node,\n      offset\n    };\n  }\n}\n\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-bp-set\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\n      \"DocumentType Node can't be used as boundary point.\",\n      \"InvalidNodeTypeError\"\n    ]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n\n  const bp = { node, offset };\n  if (\n    nodeRoot(node) !== range._root ||\n    compareBoundaryPointsPosition(bp, range._end) === 1\n  ) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n\n  const bp = { node, offset };\n  if (\n    nodeRoot(node) !== range._root ||\n    compareBoundaryPointsPosition(bp, range._start) === -1\n  ) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-select\nfunction selectNodeWithinRange(node, range) {\n  const parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  const index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n  range._setLiveRangeEnd(parent, index + 1);\n}\n\n// https://dom.spec.whatwg.org/#contained\nfunction isContained(node, range) {\n  const { _start, _end } = range;\n  return (\n    compareBoundaryPointsPosition({ node, offset: 0 }, _start) === 1 &&\n    compareBoundaryPointsPosition({ node, offset: nodeLength(node) }, _end) === -1\n  );\n}\n\n// https://dom.spec.whatwg.org/#partially-contained\nfunction isPartiallyContained(node, range) {\n  const { _start, _end } = range;\n  return (\n    (isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node)) ||\n    (!isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node))\n  );\n}\n\n// https://dom.spec.whatwg.org/#concept-range-insert\nfunction insertNodeInRange(node, range) {\n  const { node: startNode, offset: startOffset } = range._start;\n\n  if (\n    startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n    startNode.nodeType === NODE_TYPE.COMMENT_NODE ||\n    (startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode)) ||\n    node === startNode\n  ) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ?\n    startNode :\n    domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  const parent = !referenceNode ?\n    startNode :\n    domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  const nodeParent = domSymbolTree.parent(node);\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-range-clone\nfunction cloneRange(range) {\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (\n    originalStart.node === originalEnd.node &&\n    (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n\n    fragment.appendChild(cloned);\n\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\n    .filter(node => isContained(node, range));\n\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (\n    firstPartialContainedChild !== null &&\n    (\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n\n    fragment.appendChild(cloned);\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: originalStart.node, offset: originalStart.offset },\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\n    });\n\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    const cloned = clone(containedChild, undefined, true);\n    fragment.appendChild(cloned);\n  }\n\n  if (\n    lastPartiallyContainedChild !== null &&\n    (\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n\n    fragment.appendChild(cloned);\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: lastPartiallyContainedChild, offset: 0 },\n      end: { node: originalEnd.node, offset: originalEnd.offset }\n    });\n\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  return fragment;\n}\n\n// https://dom.spec.whatwg.org/#concept-range-extract\nfunction extractRange(range) {\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (\n    originalStart.node === originalEnd.node &&\n    (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\n    .filter(node => isContained(node, range));\n\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  let newNode;\n  let newOffset;\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    let referenceNode = originalStart.node;\n\n    while (\n      referenceNode &&\n      !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\n    ) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (\n    firstPartialContainedChild !== null &&\n    (\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n\n    fragment.appendChild(cloned);\n\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: originalStart.node, offset: originalStart.offset },\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\n    });\n\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    fragment.appendChild(containedChild);\n  }\n\n  if (\n    lastPartiallyContainedChild !== null &&\n    (\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n\n    fragment.appendChild(cloned);\n\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: lastPartiallyContainedChild, offset: 0 },\n      end: { node: originalEnd.node, offset: originalEnd.offset }\n    });\n\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n\n  setBoundaryPointStart,\n  setBoundaryPointEnd\n};\n"]},"metadata":{},"sourceType":"script"}