{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require(\"./encoding\"),\n    utf8Encode = _require.utf8Encode,\n    utf8DecodeWithoutBOM = _require.utf8DecodeWithoutBOM;\n\nvar _require2 = require(\"./percent-encoding\"),\n    percentDecodeBytes = _require2.percentDecodeBytes,\n    utf8PercentEncodeString = _require2.utf8PercentEncodeString,\n    isURLEncodedPercentEncode = _require2.isURLEncodedPercentEncode; // https://url.spec.whatwg.org/#concept-urlencoded-parser\n\n\nfunction parseUrlencoded(input) {\n  var sequences = strictlySplitByteSequence(input, 38);\n  var output = [];\n\n  var _iterator = _createForOfIteratorHelper(sequences),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var bytes = _step.value;\n\n      if (bytes.length === 0) {\n        continue;\n      }\n\n      var name = void 0;\n      var value = void 0;\n      var indexOfEqual = bytes.indexOf(61);\n\n      if (indexOfEqual >= 0) {\n        name = bytes.slice(0, indexOfEqual);\n        value = bytes.slice(indexOfEqual + 1);\n      } else {\n        name = bytes;\n        value = new Uint8Array(0);\n      }\n\n      name = replaceByteInByteSequence(name, 0x2B, 0x20);\n      value = replaceByteInByteSequence(value, 0x2B, 0x20);\n      var nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\n      var valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\n      output.push([nameString, valueString]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return output;\n} // https://url.spec.whatwg.org/#concept-urlencoded-string-parser\n\n\nfunction parseUrlencodedString(input) {\n  return parseUrlencoded(utf8Encode(input));\n} // https://url.spec.whatwg.org/#concept-urlencoded-serializer\n\n\nfunction serializeUrlencoded(tuples) {\n  var encodingOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var encoding = \"utf-8\";\n\n  if (encodingOverride !== undefined) {\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\n    encoding = encodingOverride;\n  }\n\n  var output = \"\";\n\n  var _iterator2 = _createForOfIteratorHelper(tuples.entries()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          i = _step2$value[0],\n          tuple = _step2$value[1];\n\n      // TODO: handle encoding override\n      var name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\n      var value = tuple[1];\n\n      if (tuple.length > 2 && tuple[2] !== undefined) {\n        if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n          value = encoding;\n        } else if (tuple[2] === \"file\") {\n          // value is a File object\n          value = value.name;\n        }\n      }\n\n      value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\n\n      if (i !== 0) {\n        output += \"&\";\n      }\n\n      output += \"\".concat(name, \"=\").concat(value);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return output;\n}\n\nfunction strictlySplitByteSequence(buf, cp) {\n  var list = [];\n  var last = 0;\n  var i = buf.indexOf(cp);\n\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n\n  return list;\n}\n\nfunction replaceByteInByteSequence(buf, from, to) {\n  var i = buf.indexOf(from);\n\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  parseUrlencodedString: parseUrlencodedString,\n  serializeUrlencoded: serializeUrlencoded\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/whatwg-url/dist/urlencoded.js"],"names":["require","utf8Encode","utf8DecodeWithoutBOM","percentDecodeBytes","utf8PercentEncodeString","isURLEncodedPercentEncode","parseUrlencoded","input","sequences","strictlySplitByteSequence","output","bytes","length","name","value","indexOfEqual","indexOf","slice","Uint8Array","replaceByteInByteSequence","nameString","valueString","push","parseUrlencodedString","serializeUrlencoded","tuples","encodingOverride","undefined","encoding","entries","i","tuple","buf","cp","list","last","from","to","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst { utf8Encode, utf8DecodeWithoutBOM } = require(\"./encoding\");\nconst { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require(\"./percent-encoding\");\n\n// https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseUrlencoded(input) {\n  const sequences = strictlySplitByteSequence(input, 38);\n  const output = [];\n  for (const bytes of sequences) {\n    if (bytes.length === 0) {\n      continue;\n    }\n\n    let name;\n    let value;\n    const indexOfEqual = bytes.indexOf(61);\n\n    if (indexOfEqual >= 0) {\n      name = bytes.slice(0, indexOfEqual);\n      value = bytes.slice(indexOfEqual + 1);\n    } else {\n      name = bytes;\n      value = new Uint8Array(0);\n    }\n\n    name = replaceByteInByteSequence(name, 0x2B, 0x20);\n    value = replaceByteInByteSequence(value, 0x2B, 0x20);\n\n    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\n    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\n\n    output.push([nameString, valueString]);\n  }\n  return output;\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-string-parser\nfunction parseUrlencodedString(input) {\n  return parseUrlencoded(utf8Encode(input));\n}\n\n// https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeUrlencoded(tuples, encodingOverride = undefined) {\n  let encoding = \"utf-8\";\n  if (encodingOverride !== undefined) {\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\n    encoding = encodingOverride;\n  }\n\n  let output = \"\";\n  for (const [i, tuple] of tuples.entries()) {\n    // TODO: handle encoding override\n\n    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\n\n    let value = tuple[1];\n    if (tuple.length > 2 && tuple[2] !== undefined) {\n      if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n        value = encoding;\n      } else if (tuple[2] === \"file\") {\n        // value is a File object\n        value = value.name;\n      }\n    }\n\n    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\n\n    if (i !== 0) {\n      output += \"&\";\n    }\n    output += `${name}=${value}`;\n  }\n  return output;\n}\n\nfunction strictlySplitByteSequence(buf, cp) {\n  const list = [];\n  let last = 0;\n  let i = buf.indexOf(cp);\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n  return list;\n}\n\nfunction replaceByteInByteSequence(buf, from, to) {\n  let i = buf.indexOf(from);\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n  return buf;\n}\n\nmodule.exports = {\n  parseUrlencodedString,\n  serializeUrlencoded\n};\n"]},"metadata":{},"sourceType":"script"}