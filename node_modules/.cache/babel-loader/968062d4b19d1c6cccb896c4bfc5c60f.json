{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Mixin = require('../../utils/mixin');\n\nvar Tokenizer = require('../../tokenizer');\n\nvar LocationInfoTokenizerMixin = require('./tokenizer-mixin');\n\nvar LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\n\nvar HTML = require('../../common/html'); //Aliases\n\n\nvar $ = HTML.TAG_NAMES;\n\nvar LocationInfoParserMixin = /*#__PURE__*/function (_Mixin) {\n  _inherits(LocationInfoParserMixin, _Mixin);\n\n  var _super = _createSuper(LocationInfoParserMixin);\n\n  function LocationInfoParserMixin(parser) {\n    var _this;\n\n    _classCallCheck(this, LocationInfoParserMixin);\n\n    _this = _super.call(this, parser);\n    _this.parser = parser;\n    _this.treeAdapter = _this.parser.treeAdapter;\n    _this.posTracker = null;\n    _this.lastStartTagToken = null;\n    _this.lastFosterParentingLocation = null;\n    _this.currentToken = null;\n    return _this;\n  }\n\n  _createClass(LocationInfoParserMixin, [{\n    key: \"_setStartLocation\",\n    value: function _setStartLocation(element) {\n      var loc = null;\n\n      if (this.lastStartTagToken) {\n        loc = Object.assign({}, this.lastStartTagToken.location);\n        loc.startTag = this.lastStartTagToken.location;\n      }\n\n      this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n  }, {\n    key: \"_setEndLocation\",\n    value: function _setEndLocation(element, closingToken) {\n      var loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n      if (loc) {\n        if (closingToken.location) {\n          var ctLoc = closingToken.location;\n          var tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n          // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n          var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n          if (isClosingEndTag) {\n            loc.endTag = Object.assign({}, ctLoc);\n            loc.endLine = ctLoc.endLine;\n            loc.endCol = ctLoc.endCol;\n            loc.endOffset = ctLoc.endOffset;\n          } else {\n            loc.endLine = ctLoc.startLine;\n            loc.endCol = ctLoc.startCol;\n            loc.endOffset = ctLoc.startOffset;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getOverriddenMethods\",\n    value: function _getOverriddenMethods(mxn, orig) {\n      return {\n        _bootstrap: function _bootstrap(document, fragmentContext) {\n          orig._bootstrap.call(this, document, fragmentContext);\n\n          mxn.lastStartTagToken = null;\n          mxn.lastFosterParentingLocation = null;\n          mxn.currentToken = null;\n          var tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n          mxn.posTracker = tokenizerMixin.posTracker;\n          Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n            onItemPop: function onItemPop(element) {\n              mxn._setEndLocation(element, mxn.currentToken);\n            }\n          });\n        },\n        _runParsingLoop: function _runParsingLoop(scriptHandler) {\n          orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n          // that remains on open element stack\n\n\n          for (var i = this.openElements.stackTop; i >= 0; i--) {\n            mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n          }\n        },\n        //Token processing\n        _processTokenInForeignContent: function _processTokenInForeignContent(token) {\n          mxn.currentToken = token;\n\n          orig._processTokenInForeignContent.call(this, token);\n        },\n        _processToken: function _processToken(token) {\n          mxn.currentToken = token;\n\n          orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n          //their end location explicitly.\n\n\n          var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n          if (requireExplicitUpdate) {\n            for (var i = this.openElements.stackTop; i >= 0; i--) {\n              var element = this.openElements.items[i];\n\n              if (this.treeAdapter.getTagName(element) === token.tagName) {\n                mxn._setEndLocation(element, token);\n\n                break;\n              }\n            }\n          }\n        },\n        //Doctype\n        _setDocumentType: function _setDocumentType(token) {\n          orig._setDocumentType.call(this, token);\n\n          var documentChildren = this.treeAdapter.getChildNodes(this.document);\n          var cnLength = documentChildren.length;\n\n          for (var i = 0; i < cnLength; i++) {\n            var node = documentChildren[i];\n\n            if (this.treeAdapter.isDocumentTypeNode(node)) {\n              this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n              break;\n            }\n          }\n        },\n        //Elements\n        _attachElementToTree: function _attachElementToTree(element) {\n          //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n          //So we will use token location stored in this methods for the element.\n          mxn._setStartLocation(element);\n\n          mxn.lastStartTagToken = null;\n\n          orig._attachElementToTree.call(this, element);\n        },\n        _appendElement: function _appendElement(token, namespaceURI) {\n          mxn.lastStartTagToken = token;\n\n          orig._appendElement.call(this, token, namespaceURI);\n        },\n        _insertElement: function _insertElement(token, namespaceURI) {\n          mxn.lastStartTagToken = token;\n\n          orig._insertElement.call(this, token, namespaceURI);\n        },\n        _insertTemplate: function _insertTemplate(token) {\n          mxn.lastStartTagToken = token;\n\n          orig._insertTemplate.call(this, token);\n\n          var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n          this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n        },\n        _insertFakeRootElement: function _insertFakeRootElement() {\n          orig._insertFakeRootElement.call(this);\n\n          this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n        },\n        //Comments\n        _appendCommentNode: function _appendCommentNode(token, parent) {\n          orig._appendCommentNode.call(this, token, parent);\n\n          var children = this.treeAdapter.getChildNodes(parent);\n          var commentNode = children[children.length - 1];\n          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n        },\n        //Text\n        _findFosterParentingLocation: function _findFosterParentingLocation() {\n          //NOTE: store last foster parenting location, so we will be able to find inserted text\n          //in case of foster parenting\n          mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n          return mxn.lastFosterParentingLocation;\n        },\n        _insertCharacters: function _insertCharacters(token) {\n          orig._insertCharacters.call(this, token);\n\n          var hasFosterParent = this._shouldFosterParentOnInsertion();\n\n          var parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n          var siblings = this.treeAdapter.getChildNodes(parent);\n          var textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n          var textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n          var tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n          if (tnLoc) {\n            tnLoc.endLine = token.location.endLine;\n            tnLoc.endCol = token.location.endCol;\n            tnLoc.endOffset = token.location.endOffset;\n          } else {\n            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n          }\n        }\n      };\n    }\n  }]);\n\n  return LocationInfoParserMixin;\n}(Mixin);\n\nmodule.exports = LocationInfoParserMixin;","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/parse5/lib/extensions/location-info/parser-mixin.js"],"names":["Mixin","require","Tokenizer","LocationInfoTokenizerMixin","LocationInfoOpenElementStackMixin","HTML","$","TAG_NAMES","LocationInfoParserMixin","parser","treeAdapter","posTracker","lastStartTagToken","lastFosterParentingLocation","currentToken","element","loc","Object","assign","location","startTag","setNodeSourceCodeLocation","closingToken","getNodeSourceCodeLocation","ctLoc","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endTag","endLine","endCol","endOffset","startLine","startCol","startOffset","mxn","orig","_bootstrap","document","fragmentContext","call","tokenizerMixin","install","tokenizer","openElements","onItemPop","_setEndLocation","_runParsingLoop","scriptHandler","i","stackTop","items","_processTokenInForeignContent","token","_processToken","requireExplicitUpdate","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_setStartLocation","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","current","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode","tnLoc","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n                if (isClosingEndTag) {\n                    loc.endTag = Object.assign({}, ctLoc);\n                    loc.endLine = ctLoc.endLine;\n                    loc.endCol = ctLoc.endCol;\n                    loc.endOffset = ctLoc.endOffset;\n                } else {\n                    loc.endLine = ctLoc.startLine;\n                    loc.endCol = ctLoc.startCol;\n                    loc.endOffset = ctLoc.startOffset;\n                }\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    tnLoc.endLine = token.location.endLine;\n                    tnLoc.endCol = token.location.endCol;\n                    tnLoc.endOffset = token.location.endOffset;\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n"]},"metadata":{},"sourceType":"script"}