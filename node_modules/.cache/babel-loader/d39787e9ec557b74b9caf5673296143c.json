{"ast":null,"code":"\"use strict\";\n/**\n * Queue for all the resources to be download except async scripts.\n * Async scripts have their own queue AsyncResourceQueue.\n */\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nmodule.exports = /*#__PURE__*/function () {\n  function ResourceQueue() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        paused = _ref.paused,\n        asyncQueue = _ref.asyncQueue;\n\n    _classCallCheck(this, ResourceQueue);\n\n    this.paused = Boolean(paused);\n    this._asyncQueue = asyncQueue;\n  }\n\n  _createClass(ResourceQueue, [{\n    key: \"getLastScript\",\n    value: function getLastScript() {\n      var head = this.tail;\n\n      while (head) {\n        if (head.isScript) {\n          return head;\n        }\n\n        head = head.prev;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_moreScripts\",\n    value: function _moreScripts() {\n      var found = false;\n      var head = this.tail;\n\n      while (head && !found) {\n        found = head.isScript;\n        head = head.prev;\n      }\n\n      return found;\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify() {\n      if (this._listener) {\n        this._listener();\n      }\n    }\n  }, {\n    key: \"setListener\",\n    value: function setListener(listener) {\n      this._listener = listener;\n    }\n  }, {\n    key: \"push\",\n    value: function push(request, onLoad, onError, keepLast, element) {\n      var isScript = element ? element.localName === \"script\" : false;\n\n      if (!request) {\n        if (isScript && !this._moreScripts()) {\n          return onLoad();\n        }\n\n        request = new Promise(function (resolve) {\n          return resolve();\n        });\n      }\n\n      var q = this;\n      var item = {\n        isScript: isScript,\n        err: null,\n        element: element,\n        fired: false,\n        data: null,\n        keepLast: keepLast,\n        prev: q.tail,\n        check: function check() {\n          var _this = this;\n\n          if (!q.paused && !this.prev && this.fired) {\n            var promise;\n\n            if (this.err && onError) {\n              promise = onError(this.err);\n            }\n\n            if (!this.err && onLoad) {\n              promise = onLoad(this.data);\n            }\n\n            Promise.resolve(promise).then(function () {\n              if (_this.next) {\n                _this.next.prev = null;\n\n                _this.next.check();\n              } else {\n                // q.tail===this\n                q.tail = null;\n\n                q._notify();\n              }\n\n              _this.finished = true;\n\n              if (q._asyncQueue) {\n                q._asyncQueue.notifyItem(_this);\n              }\n            });\n          }\n        }\n      };\n\n      if (q.tail) {\n        if (q.tail.keepLast) {\n          // if the tail is the load event in document and we receive a new element to load\n          // we should add this new request before the load event.\n          if (q.tail.prev) {\n            q.tail.prev.next = item;\n          }\n\n          item.prev = q.tail.prev;\n          q.tail.prev = item;\n          item.next = q.tail;\n        } else {\n          q.tail.next = item;\n          q.tail = item;\n        }\n      } else {\n        q.tail = item;\n      }\n\n      return request.then(function (data) {\n        item.fired = 1;\n        item.data = data;\n        item.check();\n      }).catch(function (err) {\n        item.fired = true;\n        item.err = err;\n        item.check();\n      });\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (!this.paused) {\n        return;\n      }\n\n      this.paused = false;\n      var head = this.tail;\n\n      while (head && head.prev) {\n        head = head.prev;\n      }\n\n      if (head) {\n        head.check();\n      }\n    }\n  }]);\n\n  return ResourceQueue;\n}();","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js"],"names":["module","exports","paused","asyncQueue","Boolean","_asyncQueue","head","tail","isScript","prev","found","_listener","listener","request","onLoad","onError","keepLast","element","localName","_moreScripts","Promise","resolve","q","item","err","fired","data","check","promise","then","next","_notify","finished","notifyItem","catch"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Queue for all the resources to be download except async scripts.\n * Async scripts have their own queue AsyncResourceQueue.\n */\nmodule.exports = class ResourceQueue {\n  constructor({ paused, asyncQueue } = {}) {\n    this.paused = Boolean(paused);\n    this._asyncQueue = asyncQueue;\n  }\n\n  getLastScript() {\n    let head = this.tail;\n\n    while (head) {\n      if (head.isScript) {\n        return head;\n      }\n      head = head.prev;\n    }\n\n    return null;\n  }\n\n  _moreScripts() {\n    let found = false;\n\n    let head = this.tail;\n    while (head && !found) {\n      found = head.isScript;\n      head = head.prev;\n    }\n\n    return found;\n  }\n\n  _notify() {\n    if (this._listener) {\n      this._listener();\n    }\n  }\n\n  setListener(listener) {\n    this._listener = listener;\n  }\n\n  push(request, onLoad, onError, keepLast, element) {\n    const isScript = element ? element.localName === \"script\" : false;\n\n    if (!request) {\n      if (isScript && !this._moreScripts()) {\n        return onLoad();\n      }\n\n      request = new Promise(resolve => resolve());\n    }\n    const q = this;\n    const item = {\n      isScript,\n      err: null,\n      element,\n      fired: false,\n      data: null,\n      keepLast,\n      prev: q.tail,\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          let promise;\n\n          if (this.err && onError) {\n            promise = onError(this.err);\n          }\n\n          if (!this.err && onLoad) {\n            promise = onLoad(this.data);\n          }\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check();\n              } else { // q.tail===this\n                q.tail = null;\n                q._notify();\n              }\n\n              this.finished = true;\n\n              if (q._asyncQueue) {\n                q._asyncQueue.notifyItem(this);\n              }\n            });\n        }\n      }\n    };\n    if (q.tail) {\n      if (q.tail.keepLast) {\n        // if the tail is the load event in document and we receive a new element to load\n        // we should add this new request before the load event.\n        if (q.tail.prev) {\n          q.tail.prev.next = item;\n        }\n        item.prev = q.tail.prev;\n        q.tail.prev = item;\n        item.next = q.tail;\n      } else {\n        q.tail.next = item;\n        q.tail = item;\n      }\n    } else {\n      q.tail = item;\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check();\n      })\n      .catch(err => {\n        item.fired = true;\n        item.err = err;\n        item.check();\n      });\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n\n    let head = this.tail;\n    while (head && head.prev) {\n      head = head.prev;\n    }\n    if (head) {\n      head.check();\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}