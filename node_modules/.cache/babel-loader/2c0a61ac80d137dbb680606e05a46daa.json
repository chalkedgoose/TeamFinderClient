{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(shadowIncludingInclusiveDescendantsIterator),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(shadowIncludingDescendantsIterator);\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require = require(\"./node\"),\n    nodeRoot = _require.nodeRoot;\n\nvar _require2 = require(\"./namespaces\"),\n    HTML_NS = _require2.HTML_NS;\n\nvar _require3 = require(\"./internal-constants\"),\n    domSymbolTree = _require3.domSymbolTree;\n\nvar _require4 = require(\"./mutation-observers\"),\n    signalSlotList = _require4.signalSlotList,\n    queueMutationObserverMicrotask = _require4.queueMutationObserverMicrotask; // Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\nvar VALID_HOST_ELEMENT_NAME = new Set([\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n} // Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\n\n\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n} // Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\n\n\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n} // https://dom.spec.whatwg.org/#concept-slotable\n\n\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\n\n\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n} // https://dom.spec.whatwg.org/#retarget\n\n\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    var aRoot = nodeRoot(a);\n\n    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n} // https://dom.spec.whatwg.org/#get-the-parent\n\n\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-root\n\n\nfunction shadowIncludingRoot(node) {\n  var root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n} // https://dom.spec.whatwg.org/#assign-a-slot\n\n\nfunction assignSlot(slotable) {\n  var slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables\n\n\nfunction assignSlotable(slot) {\n  var slotables = findSlotable(slot);\n  var shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (var i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  var _iterator = _createForOfIteratorHelper(slotables),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var slotable = _step.value;\n      slotable._assignedSlot = slot;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\n\n\nfunction assignSlotableForTree(root) {\n  var _iterator2 = _createForOfIteratorHelper(domSymbolTree.treeIterator(root)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var slot = _step2.value;\n\n      if (isSlot(slot)) {\n        assignSlotable(slot);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n} // https://dom.spec.whatwg.org/#find-slotables\n\n\nfunction findSlotable(slot) {\n  var result = [];\n  var root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(domSymbolTree.treeIterator(root.host)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var slotable = _step3.value;\n      var foundSlot = findSlot(slotable);\n\n      if (foundSlot === slot) {\n        result.push(slotable);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-flattened-slotables\n\n\nfunction findFlattenedSlotables(slot) {\n  var result = [];\n  var root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  var slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    var _iterator4 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(slot)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var child = _step4.value;\n\n        if (isSlotable(child)) {\n          slotables.push(child);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(slotables),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var node = _step5.value;\n\n      if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n        var temporaryResult = findFlattenedSlotables(node);\n        result.push.apply(result, _toConsumableArray(temporaryResult));\n      } else {\n        result.push(node);\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-a-slot\n\n\nfunction findSlot(slotable, openFlag) {\n  var parent = slotable.parentNode;\n\n  if (!parent) {\n    return null;\n  }\n\n  var shadow = parent._shadowRoot;\n\n  if (!shadow || openFlag && shadow.mode !== \"open\") {\n    return null;\n  }\n\n  var _iterator6 = _createForOfIteratorHelper(domSymbolTree.treeIterator(shadow)),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var child = _step6.value;\n\n      if (isSlot(child) && child.name === slotable._slotableName) {\n        return child;\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return null;\n} // https://dom.spec.whatwg.org/#signal-a-slot-change\n\n\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(function (entry) {\n    return entry === slot;\n  })) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction shadowIncludingInclusiveDescendantsIterator(node) {\n  var _iterator7, _step7, child;\n\n  return _regeneratorRuntime.wrap(function shadowIncludingInclusiveDescendantsIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return node;\n\n        case 2:\n          if (!node._shadowRoot) {\n            _context.next = 4;\n            break;\n          }\n\n          return _context.delegateYield(shadowIncludingInclusiveDescendantsIterator(node._shadowRoot), \"t0\", 4);\n\n        case 4:\n          _iterator7 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(node));\n          _context.prev = 5;\n\n          _iterator7.s();\n\n        case 7:\n          if ((_step7 = _iterator7.n()).done) {\n            _context.next = 12;\n            break;\n          }\n\n          child = _step7.value;\n          return _context.delegateYield(shadowIncludingInclusiveDescendantsIterator(child), \"t1\", 10);\n\n        case 10:\n          _context.next = 7;\n          break;\n\n        case 12:\n          _context.next = 17;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t2 = _context[\"catch\"](5);\n\n          _iterator7.e(_context.t2);\n\n        case 17:\n          _context.prev = 17;\n\n          _iterator7.f();\n\n          return _context.finish(17);\n\n        case 20:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[5, 14, 17, 20]]);\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction shadowIncludingDescendantsIterator(node) {\n  var _iterator8, _step8, child;\n\n  return _regeneratorRuntime.wrap(function shadowIncludingDescendantsIterator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!node._shadowRoot) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.delegateYield(shadowIncludingInclusiveDescendantsIterator(node._shadowRoot), \"t0\", 2);\n\n        case 2:\n          _iterator8 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(node));\n          _context2.prev = 3;\n\n          _iterator8.s();\n\n        case 5:\n          if ((_step8 = _iterator8.n()).done) {\n            _context2.next = 10;\n            break;\n          }\n\n          child = _step8.value;\n          return _context2.delegateYield(shadowIncludingInclusiveDescendantsIterator(child), \"t1\", 8);\n\n        case 8:\n          _context2.next = 5;\n          break;\n\n        case 10:\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t2 = _context2[\"catch\"](3);\n\n          _iterator8.e(_context2.t2);\n\n        case 15:\n          _context2.prev = 15;\n\n          _iterator8.f();\n\n          return _context2.finish(15);\n\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[3, 12, 15, 18]]);\n}\n\nmodule.exports = {\n  isValidHostElementName: isValidHostElementName,\n  isNode: isNode,\n  isSlotable: isSlotable,\n  isSlot: isSlot,\n  isShadowRoot: isShadowRoot,\n  isShadowInclusiveAncestor: isShadowInclusiveAncestor,\n  retarget: retarget,\n  getEventTargetParent: getEventTargetParent,\n  shadowIncludingRoot: shadowIncludingRoot,\n  assignSlot: assignSlot,\n  assignSlotable: assignSlotable,\n  assignSlotableForTree: assignSlotableForTree,\n  findSlot: findSlot,\n  findFlattenedSlotables: findFlattenedSlotables,\n  signalSlotChange: signalSlotChange,\n  shadowIncludingInclusiveDescendantsIterator: shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator: shadowIncludingDescendantsIterator\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/jsdom/lib/jsdom/living/helpers/shadow-dom.js"],"names":["shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","NODE_TYPE","require","nodeRoot","HTML_NS","domSymbolTree","signalSlotList","queueMutationObserverMicrotask","VALID_HOST_ELEMENT_NAME","Set","isValidHostElementName","name","has","isNode","nodeImpl","Boolean","isShadowRoot","nodeType","DOCUMENT_FRAGMENT_NODE","isSlotable","ELEMENT_NODE","TEXT_NODE","isSlot","localName","_namespaceURI","isShadowInclusiveAncestor","ancestor","node","host","parent","retarget","a","b","aRoot","getEventTargetParent","eventTarget","event","_getTheParent","shadowIncludingRoot","root","assignSlot","slotable","slot","findSlot","assignSlotable","slotables","findSlotable","shouldFireSlotChange","length","_assignedNodes","i","signalSlotChange","_assignedSlot","assignSlotableForTree","treeIterator","result","foundSlot","push","findFlattenedSlotables","childrenIterator","child","temporaryResult","openFlag","parentNode","shadow","_shadowRoot","mode","_slotableName","some","entry","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst { nodeRoot } = require(\"./node\");\nconst { HTML_NS } = require(\"./namespaces\");\nconst { domSymbolTree } = require(\"./internal-constants\");\nconst { signalSlotList, queueMutationObserverMicrotask } = require(\"./mutation-observers\");\n\n// Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\nconst VALID_HOST_ELEMENT_NAME = new Set([\n  \"article\",\n  \"aside\",\n  \"blockquote\",\n  \"body\",\n  \"div\",\n  \"footer\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"p\",\n  \"section\",\n  \"span\"\n]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n}\n\n// Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n}\n\n// Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n}\n\n// https://dom.spec.whatwg.org/#concept-slotable\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n}\n\n// https://dom.spec.whatwg.org/#retarget\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    const aRoot = nodeRoot(a);\n    if (\n      !isShadowRoot(aRoot) ||\n      (isNode(b) && isShadowInclusiveAncestor(aRoot, b))\n    ) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n}\n\n// https://dom.spec.whatwg.org/#get-the-parent\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-root\nfunction shadowIncludingRoot(node) {\n  const root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n}\n\n// https://dom.spec.whatwg.org/#assign-a-slot\nfunction assignSlot(slotable) {\n  const slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables\nfunction assignSlotable(slot) {\n  const slotables = findSlotable(slot);\n\n  let shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (let i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  for (const slotable of slotables) {\n    slotable._assignedSlot = slot;\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\nfunction assignSlotableForTree(root) {\n  for (const slot of domSymbolTree.treeIterator(root)) {\n    if (isSlot(slot)) {\n      assignSlotable(slot);\n    }\n  }\n}\n\n// https://dom.spec.whatwg.org/#find-slotables\nfunction findSlotable(slot) {\n  const result = [];\n\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\n    const foundSlot = findSlot(slotable);\n\n    if (foundSlot === slot) {\n      result.push(slotable);\n    }\n  }\n\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-flattened-slotables\nfunction findFlattenedSlotables(slot) {\n  const result = [];\n\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  const slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    for (const child of domSymbolTree.childrenIterator(slot)) {\n      if (isSlotable(child)) {\n        slotables.push(child);\n      }\n    }\n  }\n\n  for (const node of slotables) {\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n      const temporaryResult = findFlattenedSlotables(node);\n      result.push(...temporaryResult);\n    } else {\n      result.push(node);\n    }\n  }\n\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-a-slot\nfunction findSlot(slotable, openFlag) {\n  const { parentNode: parent } = slotable;\n\n  if (!parent) {\n    return null;\n  }\n\n  const shadow = parent._shadowRoot;\n\n  if (!shadow || (openFlag && shadow.mode !== \"open\")) {\n    return null;\n  }\n\n  for (const child of domSymbolTree.treeIterator(shadow)) {\n    if (isSlot(child) && child.name === slotable._slotableName) {\n      return child;\n    }\n  }\n\n  return null;\n}\n\n// https://dom.spec.whatwg.org/#signal-a-slot-change\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(entry => entry === slot)) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\n  yield node;\n\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingDescendantsIterator(node) {\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\nmodule.exports = {\n  isValidHostElementName,\n\n  isNode,\n  isSlotable,\n  isSlot,\n  isShadowRoot,\n\n  isShadowInclusiveAncestor,\n  retarget,\n  getEventTargetParent,\n  shadowIncludingRoot,\n\n  assignSlot,\n  assignSlotable,\n  assignSlotableForTree,\n\n  findSlot,\n  findFlattenedSlotables,\n\n  signalSlotChange,\n\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n};\n"]},"metadata":{},"sourceType":"script"}