{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require(\"../generated/utils\"),\n    wrapperForImpl = _require.wrapperForImpl; // If we were to implement the MutationObserver by spec, the MutationObservers will not be collected by the GC because\n// all the MO are kept in a mutation observer list (https://github.com/jsdom/jsdom/pull/2398/files#r238123889). The\n// mutation observer list is primarily used to invoke the mutation observer callback in the same order than the\n// mutation observer creation.\n// In order to get around this issue, we will assign an increasing id for each mutation observer, this way we would be\n// able to invoke the callback in the creation order without having to keep a list of all the mutation observers.\n\n\nvar mutationObserverId = 0; // https://dom.spec.whatwg.org/#mutationobserver\n\nvar MutationObserverImpl = /*#__PURE__*/function () {\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-mutationobserver\n  function MutationObserverImpl(globalObject, args) {\n    _classCallCheck(this, MutationObserverImpl);\n\n    var _args = _slicedToArray(args, 1),\n        callback = _args[0];\n\n    this._callback = callback;\n    this._nodeList = [];\n    this._recordQueue = [];\n    this._id = ++mutationObserverId;\n  } // https://dom.spec.whatwg.org/#dom-mutationobserver-observe\n\n\n  _createClass(MutationObserverImpl, [{\n    key: \"observe\",\n    value: function observe(target, options) {\n      var _this = this;\n\n      if ((\"attributeOldValue\" in options || \"attributeFilter\" in options) && !(\"attributes\" in options)) {\n        options.attributes = true;\n      }\n\n      if (\"characterDataOldValue\" in options & !(\"characterData\" in options)) {\n        options.characterData = true;\n      }\n\n      if (!options.childList && !options.attributes && !options.characterData) {\n        throw new TypeError(\"The options object must set at least one of 'attributes', 'characterData', or 'childList' \" + \"to true.\");\n      } else if (options.attributeOldValue && !options.attributes) {\n        throw new TypeError(\"The options object may only set 'attributeOldValue' to true when 'attributes' is true or \" + \"not present.\");\n      } else if (\"attributeFilter\" in options && !options.attributes) {\n        throw new TypeError(\"The options object may only set 'attributeFilter' when 'attributes' is true or not \" + \"present.\");\n      } else if (options.characterDataOldValue && !options.characterData) {\n        throw new TypeError(\"The options object may only set 'characterDataOldValue' to true when 'characterData' is \" + \"true or not present.\");\n      }\n\n      var existingRegisteredObserver = target._registeredObserverList.find(function (registeredObserver) {\n        return registeredObserver.observer === _this;\n      });\n\n      if (existingRegisteredObserver) {\n        var _iterator = _createForOfIteratorHelper(this._nodeList),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var node = _step.value;\n            node._registeredObserverList = node._registeredObserverList.filter(function (registeredObserver) {\n              return registeredObserver.source !== existingRegisteredObserver;\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        existingRegisteredObserver.options = options;\n      } else {\n        target._registeredObserverList.push({\n          observer: this,\n          options: options\n        });\n\n        this._nodeList.push(target);\n      }\n    } // https://dom.spec.whatwg.org/#dom-mutationobserver-disconnect\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this2 = this;\n\n      var _iterator2 = _createForOfIteratorHelper(this._nodeList),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var node = _step2.value;\n          node._registeredObserverList = node._registeredObserverList.filter(function (registeredObserver) {\n            return registeredObserver.observer !== _this2;\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._recordQueue = [];\n    } // https://dom.spec.whatwg.org/#dom-mutationobserver-takerecords\n\n  }, {\n    key: \"takeRecords\",\n    value: function takeRecords() {\n      // TODO: revisit if https://github.com/jsdom/webidl2js/pull/108 gets fixed.\n      var records = this._recordQueue.map(wrapperForImpl);\n\n      this._recordQueue = [];\n      return records;\n    }\n  }]);\n\n  return MutationObserverImpl;\n}();\n\nmodule.exports = {\n  implementation: MutationObserverImpl\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/jsdom/lib/jsdom/living/mutation-observer/MutationObserver-impl.js"],"names":["require","wrapperForImpl","mutationObserverId","MutationObserverImpl","globalObject","args","callback","_callback","_nodeList","_recordQueue","_id","target","options","attributes","characterData","childList","TypeError","attributeOldValue","characterDataOldValue","existingRegisteredObserver","_registeredObserverList","find","registeredObserver","observer","node","filter","source","push","records","map","module","exports","implementation"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { wrapperForImpl } = require(\"../generated/utils\");\n\n// If we were to implement the MutationObserver by spec, the MutationObservers will not be collected by the GC because\n// all the MO are kept in a mutation observer list (https://github.com/jsdom/jsdom/pull/2398/files#r238123889). The\n// mutation observer list is primarily used to invoke the mutation observer callback in the same order than the\n// mutation observer creation.\n// In order to get around this issue, we will assign an increasing id for each mutation observer, this way we would be\n// able to invoke the callback in the creation order without having to keep a list of all the mutation observers.\nlet mutationObserverId = 0;\n\n// https://dom.spec.whatwg.org/#mutationobserver\nclass MutationObserverImpl {\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-mutationobserver\n  constructor(globalObject, args) {\n    const [callback] = args;\n\n    this._callback = callback;\n    this._nodeList = [];\n    this._recordQueue = [];\n\n    this._id = ++mutationObserverId;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-observe\n  observe(target, options) {\n    if ((\"attributeOldValue\" in options || \"attributeFilter\" in options) && !(\"attributes\" in options)) {\n      options.attributes = true;\n    }\n\n    if (\"characterDataOldValue\" in options & !(\"characterData\" in options)) {\n      options.characterData = true;\n    }\n\n    if (!options.childList && !options.attributes && !options.characterData) {\n      throw new TypeError(\"The options object must set at least one of 'attributes', 'characterData', or 'childList' \" +\n        \"to true.\");\n    } else if (options.attributeOldValue && !options.attributes) {\n      throw new TypeError(\"The options object may only set 'attributeOldValue' to true when 'attributes' is true or \" +\n        \"not present.\");\n    } else if ((\"attributeFilter\" in options) && !options.attributes) {\n      throw new TypeError(\"The options object may only set 'attributeFilter' when 'attributes' is true or not \" +\n        \"present.\");\n    } else if (options.characterDataOldValue && !options.characterData) {\n      throw new TypeError(\"The options object may only set 'characterDataOldValue' to true when 'characterData' is \" +\n        \"true or not present.\");\n    }\n\n    const existingRegisteredObserver = target._registeredObserverList.find(registeredObserver => {\n      return registeredObserver.observer === this;\n    });\n\n    if (existingRegisteredObserver) {\n      for (const node of this._nodeList) {\n        node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n          return registeredObserver.source !== existingRegisteredObserver;\n        });\n      }\n\n      existingRegisteredObserver.options = options;\n    } else {\n      target._registeredObserverList.push({\n        observer: this,\n        options\n      });\n\n      this._nodeList.push(target);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-disconnect\n  disconnect() {\n    for (const node of this._nodeList) {\n      node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n        return registeredObserver.observer !== this;\n      });\n    }\n\n    this._recordQueue = [];\n  }\n\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-takerecords\n  takeRecords() {\n    // TODO: revisit if https://github.com/jsdom/webidl2js/pull/108 gets fixed.\n    const records = this._recordQueue.map(wrapperForImpl);\n    this._recordQueue = [];\n\n    return records;\n  }\n}\n\nmodule.exports = {\n  implementation: MutationObserverImpl\n};\n"]},"metadata":{},"sourceType":"script"}