{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parse5 = require(\"parse5\");\n\nvar _require = require(\"../../living/helpers/create-element\"),\n    _createElement = _require.createElement;\n\nvar DocumentType = require(\"../../living/generated/DocumentType\");\n\nvar DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nvar Text = require(\"../../living/generated/Text\");\n\nvar Comment = require(\"../../living/generated/Comment\");\n\nvar attributes = require(\"../../living/attributes\");\n\nvar nodeTypes = require(\"../../living/node-type\");\n\nvar serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\n\nvar _require2 = require(\"../../living/helpers/custom-elements\"),\n    customElementReactionsStack = _require2.customElementReactionsStack,\n    invokeCEReactions = _require2.invokeCEReactions,\n    lookupCEDefinition = _require2.lookupCEDefinition; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237 and\n// https://github.com/inikulin/parse5/issues/285.\n\n\nvar OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nvar openElementStackOriginalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  openElementStackOriginalPush.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n  var after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nvar openElementStackOriginalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function () {\n  var before = this.items[this.stackTop];\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  openElementStackOriginalPop.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nvar JSDOMParse5Adapter = /*#__PURE__*/function () {\n  function JSDOMParse5Adapter(documentImpl) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSDOMParse5Adapter);\n\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false; // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285. See above horrible monkey-patch for how this is maintained.\n\n    this._currentElement = undefined;\n  }\n\n  _createClass(JSDOMParse5Adapter, [{\n    key: \"_ownerDocument\",\n    value: function _ownerDocument() {\n      var _currentElement = this._currentElement; // The _currentElement is undefined when parsing elements at the root of the document.\n\n      if (_currentElement) {\n        return _currentElement.localName === \"template\" ? _currentElement.content._ownerDocument : _currentElement._ownerDocument;\n      }\n\n      return this._documentImpl;\n    }\n  }, {\n    key: \"createDocument\",\n    value: function createDocument() {\n      // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n      // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n      // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n      // return the already-created Document when asked by parse5 to \"create\" a Document.\n      return this._documentImpl;\n    }\n  }, {\n    key: \"createDocumentFragment\",\n    value: function createDocumentFragment() {\n      var ownerDocument = this._ownerDocument();\n\n      return DocumentFragment.createImpl(this._globalObject, [], {\n        ownerDocument: ownerDocument\n      });\n    } // https://html.spec.whatwg.org/#create-an-element-for-the-token\n\n  }, {\n    key: \"createElement\",\n    value: function createElement(localName, namespace, attrs) {\n      var ownerDocument = this._ownerDocument();\n\n      var isAttribute = attrs.find(function (attr) {\n        return attr.name === \"is\";\n      });\n      var isValue = isAttribute ? isAttribute.value : null;\n      var definition = lookupCEDefinition(ownerDocument, namespace, localName);\n      var willExecuteScript = false;\n\n      if (definition !== null && !this._fragment) {\n        willExecuteScript = true;\n      }\n\n      if (willExecuteScript) {\n        ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n        customElementReactionsStack.push([]);\n      }\n\n      var element = _createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n\n      this.adoptAttributes(element, attrs);\n\n      if (willExecuteScript) {\n        var queue = customElementReactionsStack.pop();\n        invokeCEReactions(queue);\n        ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n      }\n\n      if (\"_parserInserted\" in element) {\n        element._parserInserted = true;\n      }\n\n      return element;\n    }\n  }, {\n    key: \"createCommentNode\",\n    value: function createCommentNode(data) {\n      var ownerDocument = this._ownerDocument();\n\n      return Comment.createImpl(this._globalObject, [], {\n        data: data,\n        ownerDocument: ownerDocument\n      });\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(parentNode, newNode) {\n      parentNode._append(newNode);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(parentNode, newNode, referenceNode) {\n      parentNode._insert(newNode, referenceNode);\n    }\n  }, {\n    key: \"setTemplateContent\",\n    value: function setTemplateContent(templateElement, contentFragment) {\n      // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n      //\n      // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n      //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n      // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n      //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n      //\n      // At this point we now have to replace the one created in jsdom with one created by parse5.\n      var _templateElement$_tem = templateElement._templateContents,\n          _ownerDocument = _templateElement$_tem._ownerDocument,\n          _host = _templateElement$_tem._host;\n      contentFragment._ownerDocument = _ownerDocument;\n      contentFragment._host = _host;\n      templateElement._templateContents = contentFragment;\n    }\n  }, {\n    key: \"setDocumentType\",\n    value: function setDocumentType(document, name, publicId, systemId) {\n      var ownerDocument = this._ownerDocument();\n\n      var documentType = DocumentType.createImpl(this._globalObject, [], {\n        name: name,\n        publicId: publicId,\n        systemId: systemId,\n        ownerDocument: ownerDocument\n      });\n\n      document._append(documentType);\n    }\n  }, {\n    key: \"setDocumentMode\",\n    value: function setDocumentMode(document, mode) {\n      // TODO: the rest of jsdom ignores this\n      document._mode = mode;\n    }\n  }, {\n    key: \"detachNode\",\n    value: function detachNode(node) {\n      node.remove();\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(parentNode, text) {\n      var lastChild = parentNode.lastChild;\n\n      if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n        lastChild.data += text;\n      } else {\n        var ownerDocument = this._ownerDocument();\n\n        var textNode = Text.createImpl(this._globalObject, [], {\n          data: text,\n          ownerDocument: ownerDocument\n        });\n\n        parentNode._append(textNode);\n      }\n    }\n  }, {\n    key: \"insertTextBefore\",\n    value: function insertTextBefore(parentNode, text, referenceNode) {\n      var previousSibling = referenceNode.previousSibling;\n\n      if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n        previousSibling.data += text;\n      } else {\n        var ownerDocument = this._ownerDocument();\n\n        var textNode = Text.createImpl(this._globalObject, [], {\n          data: text,\n          ownerDocument: ownerDocument\n        });\n\n        parentNode._append(textNode, referenceNode);\n      }\n    }\n  }, {\n    key: \"adoptAttributes\",\n    value: function adoptAttributes(element, attrs) {\n      var _iterator = _createForOfIteratorHelper(attrs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var attr = _step.value;\n          var prefix = attr.prefix === \"\" ? null : attr.prefix;\n          attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return JSDOMParse5Adapter;\n}(); // Assign shared adapters with serializer.\n\n\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  var ownerDocument = contextElement.localName === \"template\" ? contextElement.content._ownerDocument : contextElement._ownerDocument;\n  var config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  });\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  var config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment: parseFragment,\n  parseIntoDocument: parseIntoDocument\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/jsdom/lib/jsdom/browser/parser/html.js"],"names":["parse5","require","createElement","DocumentType","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","customElementReactionsStack","invokeCEReactions","lookupCEDefinition","OpenElementStack","openElementStackOriginalPush","prototype","push","args","apply","treeAdapter","_currentElement","current","after","items","stackTop","_pushedOnStackOfOpenElements","openElementStackOriginalPop","pop","before","_poppedOffStackOfOpenElements","JSDOMParse5Adapter","documentImpl","options","_documentImpl","_globalObject","_fragment","fragment","undefined","localName","content","_ownerDocument","ownerDocument","createImpl","namespace","attrs","isAttribute","find","attr","name","isValue","value","definition","willExecuteScript","_throwOnDynamicMarkupInsertionCounter","element","adoptAttributes","queue","_parserInserted","data","parentNode","newNode","_append","referenceNode","_insert","templateElement","contentFragment","_templateContents","_host","document","publicId","systemId","documentType","mode","_mode","node","remove","text","lastChild","nodeType","TEXT_NODE","textNode","previousSibling","prefix","setAttributeValue","Object","assign","parseFragment","markup","contextElement","config","_parseOptions","parseIntoDocument","parse","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst { createElement } = require(\"../../living/helpers/create-element\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst Text = require(\"../../living/generated/Text\");\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\nconst {\n  customElementReactionsStack, invokeCEReactions, lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\");\n\n// Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237 and\n// https://github.com/inikulin/parse5/issues/285.\nconst OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nconst openElementStackOriginalPush = OpenElementStack.prototype.push;\nOpenElementStack.prototype.push = function (...args) {\n  openElementStackOriginalPush.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  const after = this.items[this.stackTop];\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nconst openElementStackOriginalPop = OpenElementStack.prototype.pop;\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n\n  openElementStackOriginalPop.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl, options = {}) {\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false;\n\n    // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285. See above horrible monkey-patch for how this is maintained.\n    this._currentElement = undefined;\n  }\n\n  _ownerDocument() {\n    const { _currentElement } = this;\n\n    // The _currentElement is undefined when parsing elements at the root of the document.\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" ?\n        _currentElement.content._ownerDocument :\n        _currentElement._ownerDocument;\n    }\n\n    return this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument });\n  }\n\n  // https://html.spec.whatwg.org/#create-an-element-for-the-token\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n\n    let willExecuteScript = false;\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n    return Comment.createImpl(this._globalObject, [], { data, ownerDocument });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const { _ownerDocument, _host } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n    const documentType = DocumentType.createImpl(this._globalObject, [], { name, publicId, systemId, ownerDocument });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n}\n\n// Assign shared adapters with serializer.\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" ?\n    contextElement.content._ownerDocument :\n    contextElement._ownerDocument;\n\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  });\n\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"]},"metadata":{},"sourceType":"script"}