{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _toConsumableArray = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ed5 = require(\"xmlchars/xml/1.0/ed5\");\n\nvar ed2 = require(\"xmlchars/xml/1.1/ed2\");\n\nvar NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\n\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nvar XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nvar XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nvar rootNS = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nvar XML_ENTITIES = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n}; // EOC: end-of-chunk\n\nvar EOC = -1;\nvar NL_LIKE = -2;\nvar S_BEGIN = 0; // Initial state.\n\nvar S_BEGIN_WHITESPACE = 1; // leading whitespace\n\nvar S_DOCTYPE = 2; // <!DOCTYPE\n\nvar S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\n\nvar S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\n\nvar S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\n\nvar S_DTD_OPEN_WAKA = 6;\nvar S_DTD_OPEN_WAKA_BANG = 7;\nvar S_DTD_COMMENT = 8; // <!--\n\nvar S_DTD_COMMENT_ENDING = 9; // <!-- blah -\n\nvar S_DTD_COMMENT_ENDED = 10; // <!-- blah --\n\nvar S_DTD_PI = 11; // <?\n\nvar S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\n\nvar S_TEXT = 13; // general stuff\n\nvar S_ENTITY = 14; // &amp and such\n\nvar S_OPEN_WAKA = 15; // <\n\nvar S_OPEN_WAKA_BANG = 16; // <!...\n\nvar S_COMMENT = 17; // <!--\n\nvar S_COMMENT_ENDING = 18; // <!-- blah -\n\nvar S_COMMENT_ENDED = 19; // <!-- blah --\n\nvar S_CDATA = 20; // <![CDATA[ something\n\nvar S_CDATA_ENDING = 21; // ]\n\nvar S_CDATA_ENDING_2 = 22; // ]]\n\nvar S_PI_FIRST_CHAR = 23; // <?hi, first char\n\nvar S_PI_REST = 24; // <?hi, rest of the name\n\nvar S_PI_BODY = 25; // <?hi there\n\nvar S_PI_ENDING = 26; // <?hi \"there\" ?\n\nvar S_XML_DECL_NAME_START = 27; // <?xml\n\nvar S_XML_DECL_NAME = 28; // <?xml foo\n\nvar S_XML_DECL_EQ = 29; // <?xml foo=\n\nvar S_XML_DECL_VALUE_START = 30; // <?xml foo=\n\nvar S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\n\nvar S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\n\nvar S_XML_DECL_ENDING = 33; // <?xml ... ?\n\nvar S_OPEN_TAG = 34; // <strong\n\nvar S_OPEN_TAG_SLASH = 35; // <strong /\n\nvar S_ATTRIB = 36; // <a\n\nvar S_ATTRIB_NAME = 37; // <a foo\n\nvar S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\n\nvar S_ATTRIB_VALUE = 39; // <a foo=\n\nvar S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\n\nvar S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\n\nvar S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\n\nvar S_CLOSE_TAG = 43; // </a\n\nvar S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\n\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\nvar BANG = 0x21;\nvar DQUOTE = 0x22;\nvar AMP = 0x26;\nvar SQUOTE = 0x27;\nvar MINUS = 0x2D;\nvar FORWARD_SLASH = 0x2F;\nvar SEMICOLON = 0x3B;\nvar LESS = 0x3C;\nvar EQUAL = 0x3D;\nvar GREATER = 0x3E;\nvar QUESTION = 0x3F;\nvar OPEN_BRACKET = 0x5B;\nvar CLOSE_BRACKET = 0x5D;\nvar NEL = 0x85;\nvar LS = 0x2028; // Line Separator\n\nvar isQuote = function isQuote(c) {\n  return c === DQUOTE || c === SQUOTE;\n};\n\nvar QUOTES = [DQUOTE, SQUOTE];\nvar DOCTYPE_TERMINATOR = [].concat(QUOTES, [OPEN_BRACKET, GREATER]);\nvar DTD_TERMINATOR = [].concat(QUOTES, [LESS, CLOSE_BRACKET]);\nvar XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION].concat(_toConsumableArray(S_LIST));\nvar ATTRIB_VALUE_UNQUOTED_TERMINATOR = [].concat(_toConsumableArray(S_LIST), [GREATER, AMP, LESS]);\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(\"xml prefix must be bound to \".concat(XML_NAMESPACE, \".\"));\n      }\n\n      break;\n\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(\"xmlns prefix must be bound to \".concat(XMLNS_NAMESPACE, \".\"));\n      }\n\n      break;\n\n    default:\n  }\n\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? \"the default namespace may not be set to \".concat(uri, \".\") : \"may not assign a prefix (even \\\"xmlns\\\") to the URI \".concat(XMLNS_NAMESPACE, \".\"));\n      break;\n\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n\n        case \"\":\n          parser.fail(\"the default namespace may not be set to \".concat(uri, \".\"));\n          break;\n\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n\n      break;\n\n    default:\n  }\n}\n\nfunction nsMappingCheck(parser, mapping) {\n  for (var _i = 0, _Object$keys = Object.keys(mapping); _i < _Object$keys.length; _i++) {\n    var local = _Object$keys[_i];\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n\nvar isNCName = function isNCName(name) {\n  return NC_NAME_RE.test(name);\n};\n\nvar isName = function isName(name) {\n  return NAME_RE.test(name);\n};\n\nvar FORBIDDEN_START = 0;\nvar FORBIDDEN_BRACKET = 1;\nvar FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\n\nexports.EVENTS = [\"xmldecl\", \"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"attribute\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nvar EVENT_NAME_TO_HANDLER_NAME = {\n  xmldecl: \"xmldeclHandler\",\n  text: \"textHandler\",\n  processinginstruction: \"piHandler\",\n  doctype: \"doctypeHandler\",\n  comment: \"commentHandler\",\n  opentagstart: \"openTagStartHandler\",\n  attribute: \"attributeHandler\",\n  opentag: \"openTagHandler\",\n  closetag: \"closeTagHandler\",\n  cdata: \"cdataHandler\",\n  error: \"errorHandler\",\n  end: \"endHandler\",\n  ready: \"readyHandler\"\n};\n\nvar SaxesParser = /*#__PURE__*/function () {\n  /**\n   * @param opt The parser options.\n   */\n  function SaxesParser(opt) {\n    _classCallCheck(this, SaxesParser);\n\n    this.opt = opt !== null && opt !== void 0 ? opt : {};\n    this.fragmentOpt = !!this.opt.fragment;\n    var xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n    this.trackPosition = this.opt.position !== false;\n    this.fileName = this.opt.fileName;\n\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsNS; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribNS; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.ns = Object.assign({\n        __proto__: null\n      }, rootNS);\n      var additional = this.opt.additionalNamespaces;\n\n      if (additional != null) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    } else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsPlain; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribPlain;\n    } //\n    // The order of the members in this table needs to correspond to the state\n    // numbers given to the states that correspond to the methods being recorded\n    // here.\n    //\n\n\n    this.stateTable = [\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite];\n\n    this._init();\n  }\n  /**\n   * Indicates whether or not the parser is closed. If ``true``, wait for\n   * the ``ready`` event to write again.\n   */\n\n\n  _createClass(SaxesParser, [{\n    key: \"_init\",\n    value: function _init() {\n      var _a;\n\n      this.openWakaBang = \"\";\n      this.text = \"\";\n      this.name = \"\";\n      this.piTarget = \"\";\n      this.entity = \"\";\n      this.q = null;\n      this.tags = [];\n      this.tag = null;\n      this.topNS = null;\n      this.chunk = \"\";\n      this.chunkPosition = 0;\n      this.i = 0;\n      this.prevI = 0;\n      this.carriedFromPrevious = undefined;\n      this.forbiddenState = FORBIDDEN_START;\n      this.attribList = []; // The logic is organized so as to minimize the need to check\n      // this.opt.fragment while parsing.\n\n      var fragmentOpt = this.fragmentOpt;\n      this.state = fragmentOpt ? S_TEXT : S_BEGIN; // We want these to be all true if we are dealing with a fragment.\n\n      this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt; // An XML declaration is intially possible only when parsing whole\n      // documents.\n\n      this.xmlDeclPossible = !fragmentOpt;\n      this.xmlDeclExpects = [\"version\"];\n      this.entityReturnState = undefined;\n      var defaultXMLVersion = this.opt.defaultXMLVersion;\n\n      if (defaultXMLVersion === undefined) {\n        if (this.opt.forceXMLVersion === true) {\n          throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n        }\n\n        defaultXMLVersion = \"1.0\";\n      }\n\n      this.setXMLVersion(defaultXMLVersion);\n      this.positionAtNewLine = 0;\n      this.doctype = false;\n      this._closed = false;\n      this.xmlDecl = {\n        version: undefined,\n        encoding: undefined,\n        standalone: undefined\n      };\n      this.line = 1;\n      this.column = 0;\n      this.ENTITIES = Object.create(XML_ENTITIES); // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n\n  }, {\n    key: \"on\",\n\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    value: function on(name, handler) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(name) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n\n  }, {\n    key: \"makeError\",\n    value: function makeError(message) {\n      var _a;\n\n      var msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n\n      if (this.trackPosition) {\n        if (msg.length > 0) {\n          msg += \":\";\n        }\n\n        msg += \"\".concat(this.line, \":\").concat(this.column);\n      }\n\n      if (msg.length > 0) {\n        msg += \": \";\n      }\n\n      return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"fail\",\n    value: function fail(message) {\n      var err = this.makeError(message);\n      var handler = this.errorHandler;\n\n      if (handler === undefined) {\n        throw err;\n      } else {\n        handler(err);\n      }\n\n      return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(chunk) {\n      if (this.closed) {\n        return this.fail(\"cannot write after close; assign an onready handler.\");\n      }\n\n      var end = false;\n\n      if (chunk === null) {\n        // We cannot return immediately because carriedFromPrevious may need\n        // processing.\n        end = true;\n        chunk = \"\";\n      } else if (typeof chunk === \"object\") {\n        chunk = chunk.toString();\n      } // We checked if performing a pre-decomposition of the string into an array\n      // of single complete characters (``Array.from(chunk)``) would be faster\n      // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n      // isn't. (There may be Node-specific code that would perform faster than\n      // ``Array.from`` but don't want to be dependent on Node.)\n\n\n      if (this.carriedFromPrevious !== undefined) {\n        // The previous chunk had char we must carry over.\n        chunk = \"\".concat(this.carriedFromPrevious).concat(chunk);\n        this.carriedFromPrevious = undefined;\n      }\n\n      var limit = chunk.length;\n      var lastCode = chunk.charCodeAt(limit - 1);\n\n      if (!end && ( // A trailing CR or surrogate must be carried over to the next\n      // chunk.\n      lastCode === CR || lastCode >= 0xD800 && lastCode <= 0xDBFF)) {\n        // The chunk ends with a character that must be carried over. We cannot\n        // know how to handle it until we get the next chunk or the end of the\n        // stream. So save it for later.\n        this.carriedFromPrevious = chunk[limit - 1];\n        limit--;\n        chunk = chunk.slice(0, limit);\n      }\n\n      var stateTable = this.stateTable;\n      this.chunk = chunk;\n      this.i = 0;\n\n      while (this.i < limit) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        stateTable[this.state].call(this);\n      }\n\n      this.chunkPosition += limit;\n      return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n\n  }, {\n    key: \"getCode10\",\n    value: function getCode10() {\n      var chunk = this.chunk,\n          i = this.i;\n      this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n      // read this.i again, which is a bit faster.\n\n      this.i = i + 1;\n\n      if (i >= chunk.length) {\n        return EOC;\n      } // Using charCodeAt and handling the surrogates ourselves is faster\n      // than using codePointAt.\n\n\n      var code = chunk.charCodeAt(i);\n      this.column++;\n\n      if (code < 0xD800) {\n        if (code >= SPACE || code === TAB) {\n          return code;\n        }\n\n        switch (code) {\n          case NL:\n            this.line++;\n            this.column = 0;\n            this.positionAtNewLine = this.position;\n            return NL;\n\n          case CR:\n            // We may get NaN if we read past the end of the chunk, which is fine.\n            if (chunk.charCodeAt(i + 1) === NL) {\n              // A \\r\\n sequence is converted to \\n so we have to skip over the\n              // next character. We already know it has a size of 1 so ++ is fine\n              // here.\n              this.i = i + 2;\n            } // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n            // ahead.\n            // In either case, \\r becomes \\n.\n\n\n            this.line++;\n            this.column = 0;\n            this.positionAtNewLine = this.position;\n            return NL_LIKE;\n\n          default:\n            // If we get here, then code < SPACE and it is not NL CR or TAB.\n            this.fail(\"disallowed character.\");\n            return code;\n        }\n      }\n\n      if (code > 0xDBFF) {\n        // This is a specialized version of isChar10 that takes into account\n        // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n        // test cases that don't need testing.\n        if (!(code >= 0xE000 && code <= 0xFFFD)) {\n          this.fail(\"disallowed character.\");\n        }\n\n        return code;\n      }\n\n      var final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n      this.i = i + 2; // This is a specialized version of isChar10 that takes into account that in\n      // this context necessarily final >= 0x10000.\n\n      if (final > 0x10FFFF) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n\n  }, {\n    key: \"getCode11\",\n    value: function getCode11() {\n      var chunk = this.chunk,\n          i = this.i;\n      this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n      // read this.i again, which is a bit faster.\n\n      this.i = i + 1;\n\n      if (i >= chunk.length) {\n        return EOC;\n      } // Using charCodeAt and handling the surrogates ourselves is faster\n      // than using codePointAt.\n\n\n      var code = chunk.charCodeAt(i);\n      this.column++;\n\n      if (code < 0xD800) {\n        if (code > 0x1F && code < 0x7F || code > 0x9F && code !== LS || code === TAB) {\n          return code;\n        }\n\n        switch (code) {\n          case NL:\n            // 0xA\n            this.line++;\n            this.column = 0;\n            this.positionAtNewLine = this.position;\n            return NL;\n\n          case CR:\n            {\n              // 0xD\n              // We may get NaN if we read past the end of the chunk, which is\n              // fine.\n              var next = chunk.charCodeAt(i + 1);\n\n              if (next === NL || next === NEL) {\n                // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                // over the next character. We already know it has a size of 1.\n                this.i = i + 2;\n              } // Otherwise, a CR is just converted to NL, no skip.\n\n            }\n\n          /* yes, fall through */\n\n          case NEL: // 0x85\n\n          case LS:\n            // Ox2028\n            this.line++;\n            this.column = 0;\n            this.positionAtNewLine = this.position;\n            return NL_LIKE;\n\n          default:\n            this.fail(\"disallowed character.\");\n            return code;\n        }\n      }\n\n      if (code > 0xDBFF) {\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n        // does not test cases that don't need testing.\n        if (!(code >= 0xE000 && code <= 0xFFFD)) {\n          this.fail(\"disallowed character.\");\n        }\n\n        return code;\n      }\n\n      var final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n      this.i = i + 2; // This is a specialized version of isCharAndNotRestricted that takes into\n      // account that in this context necessarily final >= 0x10000.\n\n      if (final > 0x10FFFF) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n\n  }, {\n    key: \"getCodeNorm\",\n    value: function getCodeNorm() {\n      var c = this.getCode();\n      return c === NL_LIKE ? NL : c;\n    }\n  }, {\n    key: \"unget\",\n    value: function unget() {\n      this.i = this.prevI;\n      this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n\n  }, {\n    key: \"captureTo\",\n    value: function captureTo(chars) {\n      var start = this.i;\n      var chunk = this.chunk; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        var c = this.getCode();\n        var isNLLike = c === NL_LIKE;\n        var final = isNLLike ? NL : c;\n\n        if (final === EOC || chars.includes(final)) {\n          this.text += chunk.slice(start, this.prevI);\n          return final;\n        }\n\n        if (isNLLike) {\n          this.text += \"\".concat(chunk.slice(start, this.prevI), \"\\n\");\n          start = this.i;\n        }\n      }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n\n  }, {\n    key: \"captureToChar\",\n    value: function captureToChar(char) {\n      var start = this.i;\n      var chunk = this.chunk; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        var c = this.getCode();\n\n        switch (c) {\n          case NL_LIKE:\n            this.text += \"\".concat(chunk.slice(start, this.prevI), \"\\n\");\n            start = this.i;\n            c = NL;\n            break;\n\n          case EOC:\n            this.text += chunk.slice(start);\n            return false;\n\n          default:\n        }\n\n        if (c === char) {\n          this.text += chunk.slice(start, this.prevI);\n          return true;\n        }\n      }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n\n  }, {\n    key: \"captureNameChars\",\n    value: function captureNameChars() {\n      var chunk = this.chunk,\n          start = this.i; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        var c = this.getCode();\n\n        if (c === EOC) {\n          this.name += chunk.slice(start);\n          return EOC;\n        } // NL is not a name char so we don't have to test specifically for it.\n\n\n        if (!isNameChar(c)) {\n          this.name += chunk.slice(start, this.prevI);\n          return c === NL_LIKE ? NL : c;\n        }\n      }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n\n  }, {\n    key: \"skipSpaces\",\n    value: function skipSpaces() {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        var c = this.getCodeNorm();\n\n        if (c === EOC || !isS(c)) {\n          return c;\n        }\n      }\n    }\n  }, {\n    key: \"setXMLVersion\",\n    value: function setXMLVersion(version) {\n      this.currentXMLVersion = version;\n      /*  eslint-disable @typescript-eslint/unbound-method */\n\n      if (version === \"1.0\") {\n        this.isChar = isChar10;\n        this.getCode = this.getCode10;\n      } else {\n        this.isChar = isChar11;\n        this.getCode = this.getCode11;\n      }\n      /* eslint-enable @typescript-eslint/unbound-method */\n\n    } // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n\n  }, {\n    key: \"sBegin\",\n    value: function sBegin() {\n      // We are essentially peeking at the first character of the chunk. Since\n      // S_BEGIN can be in effect only when we start working on the first chunk,\n      // the index at which we must look is necessarily 0. Note also that the\n      // following test does not depend on decoding surrogates.\n      // If the initial character is 0xFEFF, ignore it.\n      if (this.chunk.charCodeAt(0) === 0xFEFF) {\n        this.i++;\n        this.column++;\n      }\n\n      this.state = S_BEGIN_WHITESPACE;\n    }\n  }, {\n    key: \"sBeginWhitespace\",\n    value: function sBeginWhitespace() {\n      // We need to know whether we've encountered spaces or not because as soon\n      // as we run into a space, an XML declaration is no longer possible. Rather\n      // than slow down skipSpaces even in places where we don't care whether it\n      // skipped anything or not, we check whether prevI is equal to the value of\n      // i from before we skip spaces.\n      var iBefore = this.i;\n      var c = this.skipSpaces();\n\n      if (this.prevI !== iBefore) {\n        this.xmlDeclPossible = false;\n      }\n\n      switch (c) {\n        case LESS:\n          this.state = S_OPEN_WAKA; // We could naively call closeText but in this state, it is not normal\n          // to have text be filled with any data.\n\n          if (this.text.length !== 0) {\n            throw new Error(\"no-empty text at start\");\n          }\n\n          break;\n\n        case EOC:\n          break;\n\n        default:\n          this.unget();\n          this.state = S_TEXT;\n          this.xmlDeclPossible = false;\n      }\n    }\n  }, {\n    key: \"sDoctype\",\n    value: function sDoctype() {\n      var _a;\n\n      var c = this.captureTo(DOCTYPE_TERMINATOR);\n\n      switch (c) {\n        case GREATER:\n          {\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n            this.state = S_TEXT;\n            this.doctype = true; // just remember that we saw it.\n\n            break;\n          }\n\n        case EOC:\n          break;\n\n        default:\n          this.text += String.fromCodePoint(c);\n\n          if (c === OPEN_BRACKET) {\n            this.state = S_DTD;\n          } else if (isQuote(c)) {\n            this.state = S_DOCTYPE_QUOTE;\n            this.q = c;\n          }\n\n      }\n    }\n  }, {\n    key: \"sDoctypeQuote\",\n    value: function sDoctypeQuote() {\n      var q = this.q;\n\n      if (this.captureToChar(q)) {\n        this.text += String.fromCodePoint(q);\n        this.q = null;\n        this.state = S_DOCTYPE;\n      }\n    }\n  }, {\n    key: \"sDTD\",\n    value: function sDTD() {\n      var c = this.captureTo(DTD_TERMINATOR);\n\n      if (c === EOC) {\n        return;\n      }\n\n      this.text += String.fromCodePoint(c);\n\n      if (c === CLOSE_BRACKET) {\n        this.state = S_DOCTYPE;\n      } else if (c === LESS) {\n        this.state = S_DTD_OPEN_WAKA;\n      } else if (isQuote(c)) {\n        this.state = S_DTD_QUOTED;\n        this.q = c;\n      }\n    }\n  }, {\n    key: \"sDTDQuoted\",\n    value: function sDTDQuoted() {\n      var q = this.q;\n\n      if (this.captureToChar(q)) {\n        this.text += String.fromCodePoint(q);\n        this.state = S_DTD;\n        this.q = null;\n      }\n    }\n  }, {\n    key: \"sDTDOpenWaka\",\n    value: function sDTDOpenWaka() {\n      var c = this.getCodeNorm();\n      this.text += String.fromCodePoint(c);\n\n      switch (c) {\n        case BANG:\n          this.state = S_DTD_OPEN_WAKA_BANG;\n          this.openWakaBang = \"\";\n          break;\n\n        case QUESTION:\n          this.state = S_DTD_PI;\n          break;\n\n        default:\n          this.state = S_DTD;\n      }\n    }\n  }, {\n    key: \"sDTDOpenWakaBang\",\n    value: function sDTDOpenWakaBang() {\n      var char = String.fromCodePoint(this.getCodeNorm());\n      var owb = this.openWakaBang += char;\n      this.text += char;\n\n      if (owb !== \"-\") {\n        this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n        this.openWakaBang = \"\";\n      }\n    }\n  }, {\n    key: \"sDTDComment\",\n    value: function sDTDComment() {\n      if (this.captureToChar(MINUS)) {\n        this.text += \"-\";\n        this.state = S_DTD_COMMENT_ENDING;\n      }\n    }\n  }, {\n    key: \"sDTDCommentEnding\",\n    value: function sDTDCommentEnding() {\n      var c = this.getCodeNorm();\n      this.text += String.fromCodePoint(c);\n      this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n  }, {\n    key: \"sDTDCommentEnded\",\n    value: function sDTDCommentEnded() {\n      var c = this.getCodeNorm();\n      this.text += String.fromCodePoint(c);\n\n      if (c === GREATER) {\n        this.state = S_DTD;\n      } else {\n        this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n        // a comment of \" blah -- bloo \"\n\n        this.state = S_DTD_COMMENT;\n      }\n    }\n  }, {\n    key: \"sDTDPI\",\n    value: function sDTDPI() {\n      if (this.captureToChar(QUESTION)) {\n        this.text += \"?\";\n        this.state = S_DTD_PI_ENDING;\n      }\n    }\n  }, {\n    key: \"sDTDPIEnding\",\n    value: function sDTDPIEnding() {\n      var c = this.getCodeNorm();\n      this.text += String.fromCodePoint(c);\n\n      if (c === GREATER) {\n        this.state = S_DTD;\n      }\n    }\n  }, {\n    key: \"sText\",\n    value: function sText() {\n      //\n      // We did try a version of saxes where the S_TEXT state was split in two\n      // states: one for text inside the root element, and one for text\n      // outside. This was avoiding having to test this.tags.length to decide\n      // what implementation to actually use.\n      //\n      // Peformance testing on gigabyte-size files did not show any advantage to\n      // using the two states solution instead of the current one. Conversely, it\n      // made the code a bit more complicated elsewhere. For instance, a comment\n      // can appear before the root element so when a comment ended it was\n      // necessary to determine whether to return to the S_TEXT state or to the\n      // new text-outside-root state.\n      //\n      if (this.tags.length !== 0) {\n        this.handleTextInRoot();\n      } else {\n        this.handleTextOutsideRoot();\n      }\n    }\n  }, {\n    key: \"sEntity\",\n    value: function sEntity() {\n      // This is essentially a specialized version of captureToChar(SEMICOLON...)\n      var start = this.i;\n      var chunk = this.chunk; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n      loop: // eslint-disable-next-line no-constant-condition\n      while (true) {\n        switch (this.getCode()) {\n          case NL_LIKE:\n            this.entity += \"\".concat(chunk.slice(start, this.prevI), \"\\n\");\n            start = this.i;\n            break;\n\n          case SEMICOLON:\n            {\n              var entityReturnState = this.entityReturnState;\n              var entity = this.entity + chunk.slice(start, this.prevI);\n              this.state = entityReturnState;\n              var parsed = void 0;\n\n              if (entity === \"\") {\n                this.fail(\"empty entity name.\");\n                parsed = \"&;\";\n              } else {\n                parsed = this.parseEntity(entity);\n                this.entity = \"\";\n              }\n\n              if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                this.text += parsed;\n              } // eslint-disable-next-line no-labels\n\n\n              break loop;\n            }\n\n          case EOC:\n            this.entity += chunk.slice(start); // eslint-disable-next-line no-labels\n\n            break loop;\n\n          default:\n        }\n      }\n    }\n  }, {\n    key: \"sOpenWaka\",\n    value: function sOpenWaka() {\n      // Reminder: a state handler is called with at least one character\n      // available in the current chunk. So the first call to get code inside of\n      // a state handler cannot return ``EOC``. That's why we don't test\n      // for it.\n      var c = this.getCode(); // either a /, ?, !, or text is coming next.\n\n      if (isNameStartChar(c)) {\n        this.state = S_OPEN_TAG;\n        this.unget();\n        this.xmlDeclPossible = false;\n      } else {\n        switch (c) {\n          case FORWARD_SLASH:\n            this.state = S_CLOSE_TAG;\n            this.xmlDeclPossible = false;\n            break;\n\n          case BANG:\n            this.state = S_OPEN_WAKA_BANG;\n            this.openWakaBang = \"\";\n            this.xmlDeclPossible = false;\n            break;\n\n          case QUESTION:\n            this.state = S_PI_FIRST_CHAR;\n            break;\n\n          default:\n            this.fail(\"disallowed character in tag name\");\n            this.state = S_TEXT;\n            this.xmlDeclPossible = false;\n        }\n      }\n    }\n  }, {\n    key: \"sOpenWakaBang\",\n    value: function sOpenWakaBang() {\n      this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n\n      switch (this.openWakaBang) {\n        case \"[CDATA[\":\n          if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n          }\n\n          if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n          }\n\n          this.state = S_CDATA;\n          this.openWakaBang = \"\";\n          break;\n\n        case \"--\":\n          this.state = S_COMMENT;\n          this.openWakaBang = \"\";\n          break;\n\n        case \"DOCTYPE\":\n          this.state = S_DOCTYPE;\n\n          if (this.doctype || this.sawRoot) {\n            this.fail(\"inappropriately located doctype declaration.\");\n          }\n\n          this.openWakaBang = \"\";\n          break;\n\n        default:\n          // 7 happens to be the maximum length of the string that can possibly\n          // match one of the cases above.\n          if (this.openWakaBang.length >= 7) {\n            this.fail(\"incorrect syntax.\");\n          }\n\n      }\n    }\n  }, {\n    key: \"sComment\",\n    value: function sComment() {\n      if (this.captureToChar(MINUS)) {\n        this.state = S_COMMENT_ENDING;\n      }\n    }\n  }, {\n    key: \"sCommentEnding\",\n    value: function sCommentEnding() {\n      var _a;\n\n      var c = this.getCodeNorm();\n\n      if (c === MINUS) {\n        this.state = S_COMMENT_ENDED; // eslint-disable-next-line no-unused-expressions\n\n        (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n        this.text = \"\";\n      } else {\n        this.text += \"-\".concat(String.fromCodePoint(c));\n        this.state = S_COMMENT;\n      }\n    }\n  }, {\n    key: \"sCommentEnded\",\n    value: function sCommentEnded() {\n      var c = this.getCodeNorm();\n\n      if (c !== GREATER) {\n        this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n        // a comment of \" blah -- bloo \"\n\n        this.text += \"--\".concat(String.fromCodePoint(c));\n        this.state = S_COMMENT;\n      } else {\n        this.state = S_TEXT;\n      }\n    }\n  }, {\n    key: \"sCData\",\n    value: function sCData() {\n      if (this.captureToChar(CLOSE_BRACKET)) {\n        this.state = S_CDATA_ENDING;\n      }\n    }\n  }, {\n    key: \"sCDataEnding\",\n    value: function sCDataEnding() {\n      var c = this.getCodeNorm();\n\n      if (c === CLOSE_BRACKET) {\n        this.state = S_CDATA_ENDING_2;\n      } else {\n        this.text += \"]\".concat(String.fromCodePoint(c));\n        this.state = S_CDATA;\n      }\n    }\n  }, {\n    key: \"sCDataEnding2\",\n    value: function sCDataEnding2() {\n      var _a;\n\n      var c = this.getCodeNorm();\n\n      switch (c) {\n        case GREATER:\n          {\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n            this.state = S_TEXT;\n            break;\n          }\n\n        case CLOSE_BRACKET:\n          this.text += \"]\";\n          break;\n\n        default:\n          this.text += \"]]\".concat(String.fromCodePoint(c));\n          this.state = S_CDATA;\n      }\n    } // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n\n  }, {\n    key: \"sPIFirstChar\",\n    value: function sPIFirstChar() {\n      var c = this.getCodeNorm(); // This is first because in the case where the file is well-formed this is\n      // the branch taken. We optimize for well-formedness.\n\n      if (this.nameStartCheck(c)) {\n        this.piTarget += String.fromCodePoint(c);\n        this.state = S_PI_REST;\n      } else if (c === QUESTION || isS(c)) {\n        this.fail(\"processing instruction without a target.\");\n        this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n      } else {\n        this.fail(\"disallowed character in processing instruction name.\");\n        this.piTarget += String.fromCodePoint(c);\n        this.state = S_PI_REST;\n      }\n    }\n  }, {\n    key: \"sPIRest\",\n    value: function sPIRest() {\n      // Capture characters into a piTarget while ``this.nameCheck`` run on the\n      // character read returns true.\n      var chunk = this.chunk,\n          start = this.i; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        var c = this.getCodeNorm();\n\n        if (c === EOC) {\n          this.piTarget += chunk.slice(start);\n          return;\n        } // NL cannot satisfy this.nameCheck so we don't have to test specifically\n        // for it.\n\n\n        if (!this.nameCheck(c)) {\n          this.piTarget += chunk.slice(start, this.prevI);\n          var isQuestion = c === QUESTION;\n\n          if (isQuestion || isS(c)) {\n            if (this.piTarget === \"xml\") {\n              if (!this.xmlDeclPossible) {\n                this.fail(\"an XML declaration must be at the start of the document.\");\n              }\n\n              this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n            } else {\n              this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n            }\n          } else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n          }\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"sPIBody\",\n    value: function sPIBody() {\n      if (this.text.length === 0) {\n        var c = this.getCodeNorm();\n\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n        } else if (!isS(c)) {\n          this.text = String.fromCodePoint(c);\n        }\n      } // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n      else if (this.captureToChar(QUESTION)) {\n          this.state = S_PI_ENDING;\n        }\n    }\n  }, {\n    key: \"sPIEnding\",\n    value: function sPIEnding() {\n      var _a;\n\n      var c = this.getCodeNorm();\n\n      if (c === GREATER) {\n        var piTarget = this.piTarget;\n\n        if (piTarget.toLowerCase() === \"xml\") {\n          this.fail(\"the XML declaration must appear at the start of the document.\");\n        } // eslint-disable-next-line no-unused-expressions\n\n\n        (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n          target: piTarget,\n          body: this.text\n        });\n        this.piTarget = this.text = \"\";\n        this.state = S_TEXT;\n      } else if (c === QUESTION) {\n        // We ran into ?? as part of a processing instruction. We initially took\n        // the first ? as a sign that the PI was ending, but it is not. So we have\n        // to add it to the body but we take the new ? as a sign that the PI is\n        // ending.\n        this.text += \"?\";\n      } else {\n        this.text += \"?\".concat(String.fromCodePoint(c));\n        this.state = S_PI_BODY;\n      }\n\n      this.xmlDeclPossible = false;\n    }\n  }, {\n    key: \"sXMLDeclNameStart\",\n    value: function sXMLDeclNameStart() {\n      var c = this.skipSpaces(); // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n\n      if (c === QUESTION) {\n        // It is valid to go to S_XML_DECL_ENDING from this state.\n        this.state = S_XML_DECL_ENDING;\n        return;\n      }\n\n      if (c !== EOC) {\n        this.state = S_XML_DECL_NAME;\n        this.name = String.fromCodePoint(c);\n      }\n    }\n  }, {\n    key: \"sXMLDeclName\",\n    value: function sXMLDeclName() {\n      var c = this.captureTo(XML_DECL_NAME_TERMINATOR); // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n\n      if (c === QUESTION) {\n        this.state = S_XML_DECL_ENDING;\n        this.name += this.text;\n        this.text = \"\";\n        this.fail(\"XML declaration is incomplete.\");\n        return;\n      }\n\n      if (!(isS(c) || c === EQUAL)) {\n        return;\n      }\n\n      this.name += this.text;\n      this.text = \"\";\n\n      if (!this.xmlDeclExpects.includes(this.name)) {\n        switch (this.name.length) {\n          case 0:\n            this.fail(\"did not expect any more name/value pairs.\");\n            break;\n\n          case 1:\n            this.fail(\"expected the name \".concat(this.xmlDeclExpects[0], \".\"));\n            break;\n\n          default:\n            this.fail(\"expected one of \".concat(this.xmlDeclExpects.join(\", \")));\n        }\n      }\n\n      this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n  }, {\n    key: \"sXMLDeclEq\",\n    value: function sXMLDeclEq() {\n      var c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n\n      if (c === QUESTION) {\n        this.state = S_XML_DECL_ENDING;\n        this.fail(\"XML declaration is incomplete.\");\n        return;\n      }\n\n      if (isS(c)) {\n        return;\n      }\n\n      if (c !== EQUAL) {\n        this.fail(\"value required.\");\n      }\n\n      this.state = S_XML_DECL_VALUE_START;\n    }\n  }, {\n    key: \"sXMLDeclValueStart\",\n    value: function sXMLDeclValueStart() {\n      var c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n\n      if (c === QUESTION) {\n        this.state = S_XML_DECL_ENDING;\n        this.fail(\"XML declaration is incomplete.\");\n        return;\n      }\n\n      if (isS(c)) {\n        return;\n      }\n\n      if (!isQuote(c)) {\n        this.fail(\"value must be quoted.\");\n        this.q = SPACE;\n      } else {\n        this.q = c;\n      }\n\n      this.state = S_XML_DECL_VALUE;\n    }\n  }, {\n    key: \"sXMLDeclValue\",\n    value: function sXMLDeclValue() {\n      var c = this.captureTo([this.q, QUESTION]); // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n\n      if (c === QUESTION) {\n        this.state = S_XML_DECL_ENDING;\n        this.text = \"\";\n        this.fail(\"XML declaration is incomplete.\");\n        return;\n      }\n\n      if (c === EOC) {\n        return;\n      }\n\n      var value = this.text;\n      this.text = \"\";\n\n      switch (this.name) {\n        case \"version\":\n          {\n            this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n            var version = value;\n            this.xmlDecl.version = version; // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n\n            if (!/^1\\.[0-9]+$/.test(version)) {\n              this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n            } // When forceXMLVersion is set, the XML declaration is ignored.\n            else if (!this.opt.forceXMLVersion) {\n                this.setXMLVersion(version);\n              }\n\n            break;\n          }\n\n        case \"encoding\":\n          if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n            this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n          }\n\n          this.xmlDeclExpects = [\"standalone\"];\n          this.xmlDecl.encoding = value;\n          break;\n\n        case \"standalone\":\n          if (value !== \"yes\" && value !== \"no\") {\n            this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n          }\n\n          this.xmlDeclExpects = [];\n          this.xmlDecl.standalone = value;\n          break;\n\n        default: // We don't need to raise an error here since we've already raised one\n        // when checking what name was expected.\n\n      }\n\n      this.name = \"\";\n      this.state = S_XML_DECL_SEPARATOR;\n    }\n  }, {\n    key: \"sXMLDeclSeparator\",\n    value: function sXMLDeclSeparator() {\n      var c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n      // declaration name/value pairs.\n\n      if (c === QUESTION) {\n        // It is valid to go to S_XML_DECL_ENDING from this state.\n        this.state = S_XML_DECL_ENDING;\n        return;\n      }\n\n      if (!isS(c)) {\n        this.fail(\"whitespace required.\");\n        this.unget();\n      }\n\n      this.state = S_XML_DECL_NAME_START;\n    }\n  }, {\n    key: \"sXMLDeclEnding\",\n    value: function sXMLDeclEnding() {\n      var _a;\n\n      var c = this.getCodeNorm();\n\n      if (c === GREATER) {\n        if (this.piTarget !== \"xml\") {\n          this.fail(\"processing instructions are not allowed before root.\");\n        } else if (this.name !== \"version\" && this.xmlDeclExpects.includes(\"version\")) {\n          this.fail(\"XML declaration must contain a version.\");\n        } // eslint-disable-next-line no-unused-expressions\n\n\n        (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n        this.name = \"\";\n        this.piTarget = this.text = \"\";\n        this.state = S_TEXT;\n      } else {\n        // We got here because the previous character was a ?, but the question\n        // mark character is not valid inside any of the XML declaration\n        // name/value pairs.\n        this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n      }\n\n      this.xmlDeclPossible = false;\n    }\n  }, {\n    key: \"sOpenTag\",\n    value: function sOpenTag() {\n      var _a;\n\n      var c = this.captureNameChars();\n\n      if (c === EOC) {\n        return;\n      }\n\n      var tag = this.tag = {\n        name: this.name,\n        attributes: Object.create(null)\n      };\n      this.name = \"\";\n\n      if (this.xmlnsOpt) {\n        this.topNS = tag.ns = Object.create(null);\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n      this.sawRoot = true;\n\n      if (!this.fragmentOpt && this.closedRoot) {\n        this.fail(\"documents may contain only one root.\");\n      }\n\n      switch (c) {\n        case GREATER:\n          this.openTag();\n          break;\n\n        case FORWARD_SLASH:\n          this.state = S_OPEN_TAG_SLASH;\n          break;\n\n        default:\n          if (!isS(c)) {\n            this.fail(\"disallowed character in tag name.\");\n          }\n\n          this.state = S_ATTRIB;\n      }\n    }\n  }, {\n    key: \"sOpenTagSlash\",\n    value: function sOpenTagSlash() {\n      if (this.getCode() === GREATER) {\n        this.openSelfClosingTag();\n      } else {\n        this.fail(\"forward-slash in opening tag not followed by >.\");\n        this.state = S_ATTRIB;\n      }\n    }\n  }, {\n    key: \"sAttrib\",\n    value: function sAttrib() {\n      var c = this.skipSpaces();\n\n      if (c === EOC) {\n        return;\n      }\n\n      if (isNameStartChar(c)) {\n        this.unget();\n        this.state = S_ATTRIB_NAME;\n      } else if (c === GREATER) {\n        this.openTag();\n      } else if (c === FORWARD_SLASH) {\n        this.state = S_OPEN_TAG_SLASH;\n      } else {\n        this.fail(\"disallowed character in attribute name.\");\n      }\n    }\n  }, {\n    key: \"sAttribName\",\n    value: function sAttribName() {\n      var c = this.captureNameChars();\n\n      if (c === EQUAL) {\n        this.state = S_ATTRIB_VALUE;\n      } else if (isS(c)) {\n        this.state = S_ATTRIB_NAME_SAW_WHITE;\n      } else if (c === GREATER) {\n        this.fail(\"attribute without value.\");\n        this.pushAttrib(this.name, this.name);\n        this.name = this.text = \"\";\n        this.openTag();\n      } else if (c !== EOC) {\n        this.fail(\"disallowed character in attribute name.\");\n      }\n    }\n  }, {\n    key: \"sAttribNameSawWhite\",\n    value: function sAttribNameSawWhite() {\n      var c = this.skipSpaces();\n\n      switch (c) {\n        case EOC:\n          return;\n\n        case EQUAL:\n          this.state = S_ATTRIB_VALUE;\n          break;\n\n        default:\n          this.fail(\"attribute without value.\"); // Should we do this???\n          // this.tag.attributes[this.name] = \"\";\n\n          this.text = \"\";\n          this.name = \"\";\n\n          if (c === GREATER) {\n            this.openTag();\n          } else if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n          } else {\n            this.fail(\"disallowed character in attribute name.\");\n            this.state = S_ATTRIB;\n          }\n\n      }\n    }\n  }, {\n    key: \"sAttribValue\",\n    value: function sAttribValue() {\n      var c = this.getCodeNorm();\n\n      if (isQuote(c)) {\n        this.q = c;\n        this.state = S_ATTRIB_VALUE_QUOTED;\n      } else if (!isS(c)) {\n        this.fail(\"unquoted attribute value.\");\n        this.state = S_ATTRIB_VALUE_UNQUOTED;\n        this.unget();\n      }\n    }\n  }, {\n    key: \"sAttribValueQuoted\",\n    value: function sAttribValueQuoted() {\n      // We deliberately do not use captureTo here. The specialized code we use\n      // here is faster than using captureTo.\n      var q = this.q,\n          chunk = this.chunk;\n      var start = this.i; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        switch (this.getCode()) {\n          case q:\n            this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n            this.name = this.text = \"\";\n            this.q = null;\n            this.state = S_ATTRIB_VALUE_CLOSED;\n            return;\n\n          case AMP:\n            this.text += chunk.slice(start, this.prevI);\n            this.state = S_ENTITY;\n            this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n            return;\n\n          case NL:\n          case NL_LIKE:\n          case TAB:\n            this.text += \"\".concat(chunk.slice(start, this.prevI), \" \");\n            start = this.i;\n            break;\n\n          case LESS:\n            this.text += chunk.slice(start, this.prevI);\n            this.fail(\"disallowed character.\");\n            return;\n\n          case EOC:\n            this.text += chunk.slice(start);\n            return;\n\n          default:\n        }\n      }\n    }\n  }, {\n    key: \"sAttribValueClosed\",\n    value: function sAttribValueClosed() {\n      var c = this.getCodeNorm();\n\n      if (isS(c)) {\n        this.state = S_ATTRIB;\n      } else if (c === GREATER) {\n        this.openTag();\n      } else if (c === FORWARD_SLASH) {\n        this.state = S_OPEN_TAG_SLASH;\n      } else if (isNameStartChar(c)) {\n        this.fail(\"no whitespace between attributes.\");\n        this.unget();\n        this.state = S_ATTRIB_NAME;\n      } else {\n        this.fail(\"disallowed character in attribute name.\");\n      }\n    }\n  }, {\n    key: \"sAttribValueUnquoted\",\n    value: function sAttribValueUnquoted() {\n      // We don't do anything regarding EOL or space handling for unquoted\n      // attributes. We already have failed by the time we get here, and the\n      // contract that saxes upholds states that upon failure, it is not safe to\n      // rely on the data passed to event handlers (other than\n      // ``onerror``). Passing \"bad\" data is not a problem.\n      var c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n\n      switch (c) {\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n          break;\n\n        case LESS:\n          this.fail(\"disallowed character.\");\n          break;\n\n        case EOC:\n          break;\n\n        default:\n          if (this.text.includes(\"]]>\")) {\n            this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n          }\n\n          this.pushAttrib(this.name, this.text);\n          this.name = this.text = \"\";\n\n          if (c === GREATER) {\n            this.openTag();\n          } else {\n            this.state = S_ATTRIB;\n          }\n\n      }\n    }\n  }, {\n    key: \"sCloseTag\",\n    value: function sCloseTag() {\n      var c = this.captureNameChars();\n\n      if (c === GREATER) {\n        this.closeTag();\n      } else if (isS(c)) {\n        this.state = S_CLOSE_TAG_SAW_WHITE;\n      } else if (c !== EOC) {\n        this.fail(\"disallowed character in closing tag.\");\n      }\n    }\n  }, {\n    key: \"sCloseTagSawWhite\",\n    value: function sCloseTagSawWhite() {\n      switch (this.skipSpaces()) {\n        case GREATER:\n          this.closeTag();\n          break;\n\n        case EOC:\n          break;\n\n        default:\n          this.fail(\"disallowed character in closing tag.\");\n      }\n    } // END OF STATE ENGINE METHODS\n\n  }, {\n    key: \"handleTextInRoot\",\n    value: function handleTextInRoot() {\n      // This is essentially a specialized version of captureTo which is optimized\n      // for performing the ]]> check. A previous version of this code, checked\n      // ``this.text`` for the presence of ]]>. It simplified the code but was\n      // very costly when character data contained a lot of entities to be parsed.\n      //\n      // Since we are using a specialized loop, we also keep track of the presence\n      // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n      //\n      var start = this.i,\n          forbiddenState = this.forbiddenState;\n      var chunk = this.chunk,\n          handler = this.textHandler; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n      scanLoop: // eslint-disable-next-line no-constant-condition\n      while (true) {\n        switch (this.getCode()) {\n          case LESS:\n            {\n              this.state = S_OPEN_WAKA;\n\n              if (handler !== undefined) {\n                var text = this.text;\n                var slice = chunk.slice(start, this.prevI);\n\n                if (text.length !== 0) {\n                  handler(text + slice);\n                  this.text = \"\";\n                } else if (slice.length !== 0) {\n                  handler(slice);\n                }\n              }\n\n              forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n              break scanLoop;\n            }\n\n          case AMP:\n            this.state = S_ENTITY;\n            this.entityReturnState = S_TEXT;\n\n            if (handler !== undefined) {\n              this.text += chunk.slice(start, this.prevI);\n            }\n\n            forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n            break scanLoop;\n\n          case CLOSE_BRACKET:\n            switch (forbiddenState) {\n              case FORBIDDEN_START:\n                forbiddenState = FORBIDDEN_BRACKET;\n                break;\n\n              case FORBIDDEN_BRACKET:\n                forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                break;\n\n              case FORBIDDEN_BRACKET_BRACKET:\n                break;\n\n              default:\n                throw new Error(\"impossible state\");\n            }\n\n            break;\n\n          case GREATER:\n            if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n              this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n            }\n\n            forbiddenState = FORBIDDEN_START;\n            break;\n\n          case NL_LIKE:\n            if (handler !== undefined) {\n              this.text += \"\".concat(chunk.slice(start, this.prevI), \"\\n\");\n            }\n\n            start = this.i;\n            forbiddenState = FORBIDDEN_START;\n            break;\n\n          case EOC:\n            if (handler !== undefined) {\n              this.text += chunk.slice(start);\n            } // eslint-disable-next-line no-labels\n\n\n            break scanLoop;\n\n          default:\n            forbiddenState = FORBIDDEN_START;\n        }\n      }\n\n      this.forbiddenState = forbiddenState;\n    }\n  }, {\n    key: \"handleTextOutsideRoot\",\n    value: function handleTextOutsideRoot() {\n      // This is essentially a specialized version of captureTo which is optimized\n      // for a specialized task. We keep track of the presence of non-space\n      // characters in the text since these are errors when appearing outside the\n      // document root element.\n      var start = this.i;\n      var chunk = this.chunk,\n          handler = this.textHandler;\n      var nonSpace = false; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n      outRootLoop: // eslint-disable-next-line no-constant-condition\n      while (true) {\n        var code = this.getCode();\n\n        switch (code) {\n          case LESS:\n            {\n              this.state = S_OPEN_WAKA;\n\n              if (handler !== undefined) {\n                var text = this.text;\n                var slice = chunk.slice(start, this.prevI);\n\n                if (text.length !== 0) {\n                  handler(text + slice);\n                  this.text = \"\";\n                } else if (slice.length !== 0) {\n                  handler(slice);\n                }\n              } // eslint-disable-next-line no-labels\n\n\n              break outRootLoop;\n            }\n\n          case AMP:\n            this.state = S_ENTITY;\n            this.entityReturnState = S_TEXT;\n\n            if (handler !== undefined) {\n              this.text += chunk.slice(start, this.prevI);\n            }\n\n            nonSpace = true; // eslint-disable-next-line no-labels\n\n            break outRootLoop;\n\n          case NL_LIKE:\n            if (handler !== undefined) {\n              this.text += \"\".concat(chunk.slice(start, this.prevI), \"\\n\");\n            }\n\n            start = this.i;\n            break;\n\n          case EOC:\n            if (handler !== undefined) {\n              this.text += chunk.slice(start);\n            } // eslint-disable-next-line no-labels\n\n\n            break outRootLoop;\n\n          default:\n            if (!isS(code)) {\n              nonSpace = true;\n            }\n\n        }\n      }\n\n      if (!nonSpace) {\n        return;\n      } // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n      // to avoid reporting errors for every single character that is out of\n      // place.\n\n\n      if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n        this.fail(\"text data outside of root node.\");\n        this.reportedTextBeforeRoot = true;\n      }\n\n      if (this.closedRoot && !this.reportedTextAfterRoot) {\n        this.fail(\"text data outside of root node.\");\n        this.reportedTextAfterRoot = true;\n      }\n    }\n  }, {\n    key: \"pushAttribNS\",\n    value: function pushAttribNS(name, value) {\n      var _a;\n\n      var _this$qname = this.qname(name),\n          prefix = _this$qname.prefix,\n          local = _this$qname.local;\n\n      var attr = {\n        name: name,\n        prefix: prefix,\n        local: local,\n        value: value\n      };\n      this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n\n      if (prefix === \"xmlns\") {\n        var trimmed = value.trim();\n\n        if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n          this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n        }\n\n        this.topNS[local] = trimmed;\n        nsPairCheck(this, local, trimmed);\n      } else if (name === \"xmlns\") {\n        var _trimmed = value.trim();\n\n        this.topNS[\"\"] = _trimmed;\n        nsPairCheck(this, \"\", _trimmed);\n      }\n    }\n  }, {\n    key: \"pushAttribPlain\",\n    value: function pushAttribPlain(name, value) {\n      var _a;\n\n      var attr = {\n        name: name,\n        value: value\n      };\n      this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _a, _b;\n\n      if (!this.sawRoot) {\n        this.fail(\"document must contain a root element.\");\n      }\n\n      var tags = this.tags;\n\n      while (tags.length > 0) {\n        var tag = tags.pop();\n        this.fail(\"unclosed tag: \".concat(tag.name));\n      }\n\n      if (this.state !== S_BEGIN && this.state !== S_TEXT) {\n        this.fail(\"unexpected end.\");\n      }\n\n      var text = this.text;\n\n      if (text.length !== 0) {\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n        this.text = \"\";\n      }\n\n      this._closed = true; // eslint-disable-next-line no-unused-expressions\n\n      (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n\n      this._init();\n\n      return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(prefix) {\n      var _a, _b;\n\n      var uri = this.topNS[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n\n      var tags = this.tags;\n\n      for (var index = tags.length - 1; index >= 0; index--) {\n        uri = tags[index].ns[prefix];\n\n        if (uri !== undefined) {\n          return uri;\n        }\n      }\n\n      uri = this.ns[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n\n      return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n\n  }, {\n    key: \"qname\",\n    value: function qname(name) {\n      // This is faster than using name.split(\":\").\n      var colon = name.indexOf(\":\");\n\n      if (colon === -1) {\n        return {\n          prefix: \"\",\n          local: name\n        };\n      }\n\n      var local = name.slice(colon + 1);\n      var prefix = name.slice(0, colon);\n\n      if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n        this.fail(\"malformed name: \".concat(name, \".\"));\n      }\n\n      return {\n        prefix: prefix,\n        local: local\n      };\n    }\n  }, {\n    key: \"processAttribsNS\",\n    value: function processAttribsNS() {\n      var _a;\n\n      var attribList = this.attribList;\n      var tag = this.tag;\n      {\n        // add namespace info to tag\n        var _this$qname2 = this.qname(tag.name),\n            prefix = _this$qname2.prefix,\n            local = _this$qname2.local;\n\n        tag.prefix = prefix;\n        tag.local = local;\n        var uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n\n        if (prefix !== \"\") {\n          if (prefix === \"xmlns\") {\n            this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n          }\n\n          if (uri === \"\") {\n            this.fail(\"unbound namespace prefix: \".concat(JSON.stringify(prefix), \".\"));\n            tag.uri = prefix;\n          }\n        }\n      }\n\n      if (attribList.length === 0) {\n        return;\n      }\n\n      var attributes = tag.attributes;\n      var seen = new Set(); // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n      var _iterator = _createForOfIteratorHelper(attribList),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var attr = _step.value;\n          var name = attr.name,\n              _prefix = attr.prefix,\n              _local = attr.local;\n\n          var _uri = void 0;\n\n          var eqname = void 0;\n\n          if (_prefix === \"\") {\n            _uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n            eqname = name;\n          } else {\n            _uri = this.resolve(_prefix); // if there's any attributes with an undefined namespace,\n            // then fail on them now.\n\n            if (_uri === undefined) {\n              this.fail(\"unbound namespace prefix: \".concat(JSON.stringify(_prefix), \".\"));\n              _uri = _prefix;\n            }\n\n            eqname = \"{\".concat(_uri, \"}\").concat(_local);\n          }\n\n          if (seen.has(eqname)) {\n            this.fail(\"duplicate attribute: \".concat(eqname, \".\"));\n          }\n\n          seen.add(eqname);\n          attr.uri = _uri;\n          attributes[name] = attr;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.attribList = [];\n    }\n  }, {\n    key: \"processAttribsPlain\",\n    value: function processAttribsPlain() {\n      var attribList = this.attribList; // eslint-disable-next-line prefer-destructuring\n\n      var attributes = this.tag.attributes;\n\n      var _iterator2 = _createForOfIteratorHelper(attribList),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n              name = _step2$value.name,\n              value = _step2$value.value;\n\n          if (attributes[name] !== undefined) {\n            this.fail(\"duplicate attribute: \".concat(name, \".\"));\n          }\n\n          attributes[name] = value;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n\n  }, {\n    key: \"openTag\",\n    value: function openTag() {\n      var _a;\n\n      this.processAttribs();\n      var tags = this.tags;\n      var tag = this.tag;\n      tag.isSelfClosing = false; // There cannot be any pending text here due to the onopentagstart that was\n      // necessarily emitted before we get here. So we do not check text.\n      // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n      tags.push(tag);\n      this.state = S_TEXT;\n      this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n\n  }, {\n    key: \"openSelfClosingTag\",\n    value: function openSelfClosingTag() {\n      var _a, _b, _c;\n\n      this.processAttribs();\n      var tags = this.tags;\n      var tag = this.tag;\n      tag.isSelfClosing = true; // There cannot be any pending text here due to the onopentagstart that was\n      // necessarily emitted before we get here. So we do not check text.\n      // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag); // eslint-disable-next-line no-unused-expressions\n\n      (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n      var top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n\n      if (top === null) {\n        this.closedRoot = true;\n      }\n\n      this.state = S_TEXT;\n      this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n\n  }, {\n    key: \"closeTag\",\n    value: function closeTag() {\n      var tags = this.tags,\n          name = this.name; // Our state after this will be S_TEXT, no matter what, and we can clear\n      // tagName now.\n\n      this.state = S_TEXT;\n      this.name = \"\";\n\n      if (name === \"\") {\n        this.fail(\"weird empty close tag.\");\n        this.text += \"</>\";\n        return;\n      }\n\n      var handler = this.closeTagHandler;\n      var l = tags.length;\n\n      while (l-- > 0) {\n        var tag = this.tag = tags.pop();\n        this.topNS = tag.ns; // eslint-disable-next-line no-unused-expressions\n\n        handler === null || handler === void 0 ? void 0 : handler(tag);\n\n        if (tag.name === name) {\n          break;\n        }\n\n        this.fail(\"unexpected close tag.\");\n      }\n\n      if (l === 0) {\n        this.closedRoot = true;\n      } else if (l < 0) {\n        this.fail(\"unmatched closing tag: \".concat(name, \".\"));\n        this.text += \"</\".concat(name, \">\");\n      }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n\n  }, {\n    key: \"parseEntity\",\n    value: function parseEntity(entity) {\n      // startsWith would be significantly slower for this test.\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      if (entity[0] !== \"#\") {\n        var defined = this.ENTITIES[entity];\n\n        if (defined !== undefined) {\n          return defined;\n        }\n\n        this.fail(this.isName(entity) ? \"undefined entity.\" : \"disallowed character in entity name.\");\n        return \"&\".concat(entity, \";\");\n      }\n\n      var num = NaN;\n\n      if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n        num = parseInt(entity.slice(2), 16);\n      } else if (/^#[0-9]+$/.test(entity)) {\n        num = parseInt(entity.slice(1), 10);\n      } // The character reference is required to match the CHAR production.\n\n\n      if (!this.isChar(num)) {\n        this.fail(\"malformed character entity.\");\n        return \"&\".concat(entity, \";\");\n      }\n\n      return String.fromCodePoint(num);\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n\n  }, {\n    key: \"columnIndex\",\n    get: function get() {\n      return this.position - this.positionAtNewLine;\n    }\n  }]);\n\n  return SaxesParser;\n}();\n\nexports.SaxesParser = SaxesParser;","map":{"version":3,"sources":["../../src/saxes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\nclass SaxesParser {\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n        ];\n        this._init();\n    }\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                // eslint-disable-next-line no-unused-expressions\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                // eslint-disable-next-line no-unused-expressions\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        // eslint-disable-next-line no-unused-expressions\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        // eslint-disable-next-line no-unused-expressions\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            // eslint-disable-next-line no-unused-expressions\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map"]},"metadata":{},"sourceType":"script"}