{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar reportException = require(\"../helpers/runtime-script-errors\");\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar _require = require(\"../helpers/node\"),\n    nodeRoot = _require.nodeRoot;\n\nvar _require2 = require(\"../helpers/shadow-dom\"),\n    isNode = _require2.isNode,\n    isShadowRoot = _require2.isShadowRoot,\n    isSlotable = _require2.isSlotable,\n    getEventTargetParent = _require2.getEventTargetParent,\n    isShadowInclusiveAncestor = _require2.isShadowInclusiveAncestor,\n    retarget = _require2.retarget;\n\nvar MouseEvent = require(\"../generated/MouseEvent\");\n\nvar EVENT_PHASE = {\n  NONE: 0,\n  CAPTURING_PHASE: 1,\n  AT_TARGET: 2,\n  BUBBLING_PHASE: 3\n};\n\nvar EventTargetImpl = /*#__PURE__*/function () {\n  function EventTargetImpl(globalObject) {\n    _classCallCheck(this, EventTargetImpl);\n\n    this._globalObject = globalObject;\n    this._eventListeners = Object.create(null);\n  }\n\n  _createClass(EventTargetImpl, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, callback, options) {\n      options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n      if (callback === null) {\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        this._eventListeners[type] = [];\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.callback.objectReference === callback.objectReference && listener.options.capture === options.capture) {\n          return;\n        }\n      }\n\n      this._eventListeners[type].push({\n        callback: callback,\n        options: options\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback, options) {\n      options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n      if (callback === null) {\n        // Optimization, not in the spec.\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        return;\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.callback.objectReference === callback.objectReference && listener.options.capture === options.capture) {\n          this._eventListeners[type].splice(i, 1);\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventImpl) {\n      if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n        throw DOMException.create(this._globalObject, [\"Tried to dispatch an uninitialized event\", \"InvalidStateError\"]);\n      }\n\n      if (eventImpl.eventPhase !== EVENT_PHASE.NONE) {\n        throw DOMException.create(this._globalObject, [\"Tried to dispatch a dispatching event\", \"InvalidStateError\"]);\n      }\n\n      eventImpl.isTrusted = false;\n      return this._dispatch(eventImpl);\n    } // https://dom.spec.whatwg.org/#get-the-parent\n\n  }, {\n    key: \"_getTheParent\",\n    value: function _getTheParent() {\n      return null;\n    } // https://dom.spec.whatwg.org/#concept-event-dispatch\n    // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(eventImpl, targetOverride\n    /* , legacyOutputDidListenersThrowFlag */\n    ) {\n      var targetImpl = this;\n      var clearTargets = false;\n      var activationTarget = null;\n      eventImpl._dispatchFlag = true;\n      targetOverride = targetOverride || targetImpl;\n      var relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n      if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n        var touchTargets = [];\n        appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n        var isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n        if (isActivationEvent && targetImpl._hasActivationBehavior) {\n          activationTarget = targetImpl;\n        }\n\n        var slotInClosedTree = false;\n        var slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n        var parent = getEventTargetParent(targetImpl, eventImpl); // Populate event path\n        // https://dom.spec.whatwg.org/#event-path\n\n        while (parent !== null) {\n          if (slotable !== null) {\n            if (parent.localName !== \"slot\") {\n              throw new Error(\"JSDOM Internal Error: Expected parent to be a Slot\");\n            }\n\n            slotable = null;\n            var parentRoot = nodeRoot(parent);\n\n            if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n              slotInClosedTree = true;\n            }\n          }\n\n          if (isSlotable(parent) && parent._assignedSlot) {\n            slotable = parent;\n          }\n\n          relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n          if (isNode(parent) && isShadowInclusiveAncestor(nodeRoot(targetImpl), parent) || idlUtils.wrapperForImpl(parent).constructor.name === \"Window\") {\n            if (isActivationEvent && eventImpl.bubbles && activationTarget === null && parent._hasActivationBehavior) {\n              activationTarget = parent;\n            }\n\n            appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n          } else if (parent === relatedTarget) {\n            parent = null;\n          } else {\n            targetImpl = parent;\n\n            if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n              activationTarget = targetImpl;\n            }\n\n            appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n          }\n\n          if (parent !== null) {\n            parent = getEventTargetParent(parent, eventImpl);\n          }\n\n          slotInClosedTree = false;\n        }\n\n        var clearTargetsStructIndex = -1;\n\n        for (var i = eventImpl._path.length - 1; i >= 0 && clearTargetsStructIndex === -1; i--) {\n          if (eventImpl._path[i].target !== null) {\n            clearTargetsStructIndex = i;\n          }\n        }\n\n        var clearTargetsStruct = eventImpl._path[clearTargetsStructIndex];\n        clearTargets = isNode(clearTargetsStruct.target) && isShadowRoot(nodeRoot(clearTargetsStruct.target)) || isNode(clearTargetsStruct.relatedTarget) && isShadowRoot(nodeRoot(clearTargetsStruct.relatedTarget));\n\n        if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n          activationTarget._legacyPreActivationBehavior();\n        }\n\n        for (var _i = eventImpl._path.length - 1; _i >= 0; --_i) {\n          var struct = eventImpl._path[_i];\n\n          if (struct.target !== null) {\n            eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n          } else {\n            eventImpl.eventPhase = EVENT_PHASE.CAPTURING_PHASE;\n          }\n\n          invokeEventListeners(struct, eventImpl, \"capturing\");\n        }\n\n        for (var _i2 = 0; _i2 < eventImpl._path.length; _i2++) {\n          var _struct = eventImpl._path[_i2];\n\n          if (_struct.target !== null) {\n            eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n          } else {\n            if (!eventImpl.bubbles) {\n              continue;\n            }\n\n            eventImpl.eventPhase = EVENT_PHASE.BUBBLING_PHASE;\n          }\n\n          invokeEventListeners(_struct, eventImpl, \"bubbling\");\n        }\n      }\n\n      eventImpl.eventPhase = EVENT_PHASE.NONE;\n      eventImpl.currentTarget = null;\n      eventImpl._path = [];\n      eventImpl._dispatchFlag = false;\n      eventImpl._stopPropagationFlag = false;\n      eventImpl._stopImmediatePropagationFlag = false;\n\n      if (clearTargets) {\n        eventImpl.target = null;\n        eventImpl.relatedTarget = null;\n      }\n\n      if (activationTarget !== null) {\n        if (!eventImpl._canceledFlag) {\n          activationTarget._activationBehavior(eventImpl);\n        } else if (activationTarget._legacyCanceledActivationBehavior) {\n          activationTarget._legacyCanceledActivationBehavior();\n        }\n      }\n\n      return !eventImpl._canceledFlag;\n    }\n  }]);\n\n  return EventTargetImpl;\n}();\n\nmodule.exports = {\n  implementation: EventTargetImpl\n}; // https://dom.spec.whatwg.org/#concept-event-listener-invoke\n\nfunction invokeEventListeners(struct, eventImpl, phase) {\n  var structIndex = eventImpl._path.indexOf(struct);\n\n  for (var i = structIndex; i >= 0; i--) {\n    var t = eventImpl._path[i];\n\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(struct.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(struct.item);\n  var listeners = struct.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners, phase, struct);\n} // https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\n\n\nfunction innerInvokeEventListeners(eventImpl, listeners, phase) {\n  var found = false;\n  var type = eventImpl.type,\n      target = eventImpl.target;\n  var wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  } // Copy event listeners before iterating since the list can be modified during the iteration.\n\n\n  var handlers = listeners[type].slice();\n\n  for (var i = 0; i < handlers.length; i++) {\n    var listener = handlers[i];\n    var _listener$options = listener.options,\n        capture = _listener$options.capture,\n        once = _listener$options.once,\n        passive = _listener$options.passive; // Check if the event listener has been removed since the listeners has been cloned.\n\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (phase === \"capturing\" && !capture || phase === \"bubbling\" && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      listener.callback.call(eventImpl.currentTarget, eventImpl);\n    } catch (e) {\n      var window = null;\n\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by some non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  var returnValue = {}; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(function (k) {\n      return k !== \"capture\";\n    });\n  }\n\n  var _iterator = _createForOfIteratorHelper(defaultBoolKeys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      returnValue[key] = Boolean(options[key]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return returnValue;\n} // https://dom.spec.whatwg.org/#concept-event-path-append\n\n\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  var itemInShadowTree = isNode(target) && isShadowRoot(nodeRoot(target));\n  var rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree: itemInShadowTree,\n    target: targetOverride,\n    relatedTarget: relatedTarget,\n    touchTargets: touchTargets,\n    rootOfClosedTree: rootOfClosedTree,\n    slotInClosedTree: slotInClosedTree\n  });\n}","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js"],"names":["DOMException","require","reportException","idlUtils","nodeRoot","isNode","isShadowRoot","isSlotable","getEventTargetParent","isShadowInclusiveAncestor","retarget","MouseEvent","EVENT_PHASE","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","EventTargetImpl","globalObject","_globalObject","_eventListeners","Object","create","type","callback","options","normalizeEventHandlerOptions","i","length","listener","objectReference","capture","push","splice","eventImpl","_dispatchFlag","_initializedFlag","eventPhase","isTrusted","_dispatch","targetOverride","targetImpl","clearTargets","activationTarget","relatedTarget","touchTargets","appendToEventPath","isActivationEvent","isImpl","_hasActivationBehavior","slotInClosedTree","slotable","_assignedSlot","parent","localName","Error","parentRoot","mode","wrapperForImpl","constructor","name","bubbles","clearTargetsStructIndex","_path","target","clearTargetsStruct","_legacyPreActivationBehavior","struct","invokeEventListeners","currentTarget","_stopPropagationFlag","_stopImmediatePropagationFlag","_canceledFlag","_activationBehavior","_legacyCanceledActivationBehavior","module","exports","implementation","phase","structIndex","indexOf","t","item","listeners","innerInvokeEventListeners","found","wrapper","handlers","slice","once","passive","includes","_inPassiveListenerFlag","call","e","window","_document","_ownerDocument","_defaultView","defaultBoolKeys","returnValue","Boolean","filter","k","key","itemInShadowTree","rootOfClosedTree"],"mappings":"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","sourcesContent":["\"use strict\";\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst idlUtils = require(\"../generated/utils\");\nconst { nodeRoot } = require(\"../helpers/node\");\nconst {\n  isNode, isShadowRoot, isSlotable, getEventTargetParent,\n  isShadowInclusiveAncestor, retarget\n} = require(\"../helpers/shadow-dom\");\n\nconst MouseEvent = require(\"../generated/MouseEvent\");\n\nconst EVENT_PHASE = {\n  NONE: 0,\n  CAPTURING_PHASE: 1,\n  AT_TARGET: 2,\n  BUBBLING_PHASE: 3\n};\n\nclass EventTargetImpl {\n  constructor(globalObject) {\n    this._globalObject = globalObject;\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (\n        listener.callback.objectReference === callback.objectReference &&\n        listener.options.capture === options.capture\n      ) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (\n        listener.callback.objectReference === callback.objectReference &&\n        listener.options.capture === options.capture\n      ) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw DOMException.create(this._globalObject, [\n        \"Tried to dispatch an uninitialized event\",\n        \"InvalidStateError\"\n      ]);\n    }\n    if (eventImpl.eventPhase !== EVENT_PHASE.NONE) {\n      throw DOMException.create(this._globalObject, [\n        \"Tried to dispatch a dispatching event\",\n        \"InvalidStateError\"\n      ]);\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#get-the-parent\n  _getTheParent() {\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-event-dispatch\n  // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n  _dispatch(eventImpl, targetOverride /* , legacyOutputDidListenersThrowFlag */) {\n    let targetImpl = this;\n    let clearTargets = false;\n    let activationTarget = null;\n\n    eventImpl._dispatchFlag = true;\n\n    targetOverride = targetOverride || targetImpl;\n    let relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n    if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n      const touchTargets = [];\n\n      appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n\n      const isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n      if (isActivationEvent && targetImpl._hasActivationBehavior) {\n        activationTarget = targetImpl;\n      }\n\n      let slotInClosedTree = false;\n      let slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n      let parent = getEventTargetParent(targetImpl, eventImpl);\n\n      // Populate event path\n      // https://dom.spec.whatwg.org/#event-path\n      while (parent !== null) {\n        if (slotable !== null) {\n          if (parent.localName !== \"slot\") {\n            throw new Error(`JSDOM Internal Error: Expected parent to be a Slot`);\n          }\n\n          slotable = null;\n\n          const parentRoot = nodeRoot(parent);\n          if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n            slotInClosedTree = true;\n          }\n        }\n\n        if (isSlotable(parent) && parent._assignedSlot) {\n          slotable = parent;\n        }\n\n        relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n        if (\n          (isNode(parent) && isShadowInclusiveAncestor(nodeRoot(targetImpl), parent)) ||\n          idlUtils.wrapperForImpl(parent).constructor.name === \"Window\"\n        ) {\n          if (isActivationEvent && eventImpl.bubbles && activationTarget === null &&\n              parent._hasActivationBehavior) {\n            activationTarget = parent;\n          }\n\n          appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n        } else if (parent === relatedTarget) {\n          parent = null;\n        } else {\n          targetImpl = parent;\n\n          if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n            activationTarget = targetImpl;\n          }\n\n          appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n        }\n\n        if (parent !== null) {\n          parent = getEventTargetParent(parent, eventImpl);\n        }\n\n        slotInClosedTree = false;\n      }\n\n      let clearTargetsStructIndex = -1;\n      for (let i = eventImpl._path.length - 1; i >= 0 && clearTargetsStructIndex === -1; i--) {\n        if (eventImpl._path[i].target !== null) {\n          clearTargetsStructIndex = i;\n        }\n      }\n      const clearTargetsStruct = eventImpl._path[clearTargetsStructIndex];\n\n      clearTargets =\n          (isNode(clearTargetsStruct.target) && isShadowRoot(nodeRoot(clearTargetsStruct.target))) ||\n          (isNode(clearTargetsStruct.relatedTarget) && isShadowRoot(nodeRoot(clearTargetsStruct.relatedTarget)));\n\n      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n        activationTarget._legacyPreActivationBehavior();\n      }\n\n      for (let i = eventImpl._path.length - 1; i >= 0; --i) {\n        const struct = eventImpl._path[i];\n\n        if (struct.target !== null) {\n          eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n        } else {\n          eventImpl.eventPhase = EVENT_PHASE.CAPTURING_PHASE;\n        }\n\n        invokeEventListeners(struct, eventImpl, \"capturing\");\n      }\n\n      for (let i = 0; i < eventImpl._path.length; i++) {\n        const struct = eventImpl._path[i];\n\n        if (struct.target !== null) {\n          eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n        } else {\n          if (!eventImpl.bubbles) {\n            continue;\n          }\n\n          eventImpl.eventPhase = EVENT_PHASE.BUBBLING_PHASE;\n        }\n\n        invokeEventListeners(struct, eventImpl, \"bubbling\");\n      }\n    }\n\n    eventImpl.eventPhase = EVENT_PHASE.NONE;\n\n    eventImpl.currentTarget = null;\n    eventImpl._path = [];\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n\n    if (clearTargets) {\n      eventImpl.target = null;\n      eventImpl.relatedTarget = null;\n    }\n\n    if (activationTarget !== null) {\n      if (!eventImpl._canceledFlag) {\n        activationTarget._activationBehavior(eventImpl);\n      } else if (activationTarget._legacyCanceledActivationBehavior) {\n        activationTarget._legacyCanceledActivationBehavior();\n      }\n    }\n\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\n// https://dom.spec.whatwg.org/#concept-event-listener-invoke\nfunction invokeEventListeners(struct, eventImpl, phase) {\n  const structIndex = eventImpl._path.indexOf(struct);\n  for (let i = structIndex; i >= 0; i--) {\n    const t = eventImpl._path[i];\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(struct.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(struct.item);\n\n  const listeners = struct.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners, phase, struct);\n}\n\n// https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\nfunction innerInvokeEventListeners(eventImpl, listeners, phase) {\n  let found = false;\n\n  const { type, target } = eventImpl;\n  const wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  }\n\n  // Copy event listeners before iterating since the list can be modified during the iteration.\n  const handlers = listeners[type].slice();\n\n  for (let i = 0; i < handlers.length; i++) {\n    const listener = handlers[i];\n    const { capture, once, passive } = listener.options;\n\n    // Check if the event listener has been removed since the listeners has been cloned.\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (\n      (phase === \"capturing\" && !capture) ||\n      (phase === \"bubbling\" && capture)\n    ) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      listener.callback.call(eventImpl.currentTarget, eventImpl);\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by some non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n\n// https://dom.spec.whatwg.org/#concept-event-path-append\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  const itemInShadowTree = isNode(target) && isShadowRoot(nodeRoot(target));\n  const rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree,\n    target: targetOverride,\n    relatedTarget,\n    touchTargets,\n    rootOfClosedTree,\n    slotInClosedTree\n  });\n}\n"]},"metadata":{},"sourceType":"script"}