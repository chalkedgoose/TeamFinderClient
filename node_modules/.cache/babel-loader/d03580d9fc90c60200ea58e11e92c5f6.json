{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar punycode = require(\"punycode\");\n\nvar regexes = require(\"./lib/regexes.js\");\n\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar _require = require(\"./lib/statusMapping.js\"),\n    STATUS_MAPPING = _require.STATUS_MAPPING;\n\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/.test(str);\n}\n\nfunction findStatus(val, _ref) {\n  var useSTD3ASCIIRules = _ref.useSTD3ASCIIRules;\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n    var target = mappingTable[mid];\n    var min = Array.isArray(target[0]) ? target[0][0] : target[0];\n    var max = Array.isArray(target[0]) ? target[0][1] : target[0];\n\n    if (min <= val && max >= val) {\n      if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {\n        return [STATUS_MAPPING.disallowed].concat(_toConsumableArray(target.slice(2)));\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {\n        return [STATUS_MAPPING.valid].concat(_toConsumableArray(target.slice(2)));\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {\n        return [STATUS_MAPPING.mapped].concat(_toConsumableArray(target.slice(2)));\n      }\n\n      return target.slice(1);\n    } else if (min > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nfunction mapChars(domainName, _ref2) {\n  var useSTD3ASCIIRules = _ref2.useSTD3ASCIIRules,\n      processingOption = _ref2.processingOption;\n  var hasError = false;\n  var processed = \"\";\n\n  var _iterator = _createForOfIteratorHelper(domainName),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ch = _step.value;\n\n      var _findStatus = findStatus(ch.codePointAt(0), {\n        useSTD3ASCIIRules: useSTD3ASCIIRules\n      }),\n          _findStatus2 = _slicedToArray(_findStatus, 2),\n          status = _findStatus2[0],\n          mapping = _findStatus2[1];\n\n      switch (status) {\n        case STATUS_MAPPING.disallowed:\n          hasError = true;\n          processed += ch;\n          break;\n\n        case STATUS_MAPPING.ignored:\n          break;\n\n        case STATUS_MAPPING.mapped:\n          processed += mapping;\n          break;\n\n        case STATUS_MAPPING.deviation:\n          if (processingOption === \"transitional\") {\n            processed += mapping;\n          } else {\n            processed += ch;\n          }\n\n          break;\n\n        case STATUS_MAPPING.valid:\n          processed += ch;\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nfunction validateLabel(label, _ref3) {\n  var checkHyphens = _ref3.checkHyphens,\n      checkBidi = _ref3.checkBidi,\n      checkJoiners = _ref3.checkJoiners,\n      processingOption = _ref3.processingOption,\n      useSTD3ASCIIRules = _ref3.useSTD3ASCIIRules;\n\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n\n  var codePoints = Array.from(label);\n\n  if (checkHyphens) {\n    if (codePoints[2] === \"-\" && codePoints[3] === \"-\" || label.startsWith(\"-\") || label.endsWith(\"-\")) {\n      return false;\n    }\n  }\n\n  if (label.includes(\".\") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {\n    return false;\n  }\n\n  for (var _i = 0, _codePoints = codePoints; _i < _codePoints.length; _i++) {\n    var ch = _codePoints[_i];\n\n    var _findStatus3 = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules: useSTD3ASCIIRules\n    }),\n        _findStatus4 = _slicedToArray(_findStatus3, 1),\n        status = _findStatus4[0];\n\n    if (processingOption === \"transitional\" && status !== STATUS_MAPPING.valid || processingOption === \"nontransitional\" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {\n      return false;\n    }\n  } // https://tools.ietf.org/html/rfc5892#appendix-A\n\n\n  if (checkJoiners) {\n    var last = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(codePoints.entries()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            i = _step2$value[0],\n            _ch = _step2$value[1];\n\n        if (_ch === \"\\u200C\" || _ch === \"\\u200D\") {\n          if (i > 0) {\n            if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n              continue;\n            }\n\n            if (_ch === \"\\u200C\") {\n              // TODO: make this more efficient\n              var next = codePoints.indexOf(\"\\u200C\", i + 1);\n              var test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n\n              if (regexes.validZWNJ.test(test.join(\"\"))) {\n                last = i + 1;\n                continue;\n              }\n            }\n          }\n\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } // https://tools.ietf.org/html/rfc5893#section-2\n\n\n  if (checkBidi) {\n    var rtl; // 1\n\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {\n      // 5-6\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isBidiDomain(labels) {\n  var domain = labels.map(function (label) {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch (err) {\n        return \"\";\n      }\n    }\n\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\n\nfunction processing(domainName, options) {\n  var processingOption = options.processingOption; // 1. Map.\n\n  var _mapChars = mapChars(domainName, options),\n      string = _mapChars.string,\n      error = _mapChars.error; // 2. Normalize.\n\n\n  string = string.normalize(\"NFC\"); // 3. Break.\n\n  var labels = string.split(\".\");\n  var isBidi = isBidiDomain(labels); // 4. Convert/Validate.\n\n  var _iterator3 = _createForOfIteratorHelper(labels.entries()),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n          i = _step3$value[0],\n          origLabel = _step3$value[1];\n\n      var label = origLabel;\n      var curProcessing = processingOption;\n\n      if (label.startsWith(\"xn--\")) {\n        try {\n          label = punycode.decode(label.substring(4));\n          labels[i] = label;\n        } catch (err) {\n          error = true;\n          continue;\n        }\n\n        curProcessing = \"nontransitional\";\n      } // No need to validate if we already know there is an error.\n\n\n      if (error) {\n        continue;\n      }\n\n      var validation = validateLabel(label, Object.assign({}, options, {\n        processingOption: curProcessing,\n        checkBidi: options.checkBidi && isBidi\n      }));\n\n      if (!validation) {\n        error = true;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: error\n  };\n}\n\nfunction toASCII(domainName) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref4$checkHyphens = _ref4.checkHyphens,\n      checkHyphens = _ref4$checkHyphens === void 0 ? false : _ref4$checkHyphens,\n      _ref4$checkBidi = _ref4.checkBidi,\n      checkBidi = _ref4$checkBidi === void 0 ? false : _ref4$checkBidi,\n      _ref4$checkJoiners = _ref4.checkJoiners,\n      checkJoiners = _ref4$checkJoiners === void 0 ? false : _ref4$checkJoiners,\n      _ref4$useSTD3ASCIIRul = _ref4.useSTD3ASCIIRules,\n      useSTD3ASCIIRules = _ref4$useSTD3ASCIIRul === void 0 ? false : _ref4$useSTD3ASCIIRul,\n      _ref4$processingOptio = _ref4.processingOption,\n      processingOption = _ref4$processingOptio === void 0 ? \"nontransitional\" : _ref4$processingOptio,\n      _ref4$verifyDNSLength = _ref4.verifyDNSLength,\n      verifyDNSLength = _ref4$verifyDNSLength === void 0 ? false : _ref4$verifyDNSLength;\n\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\n  }\n\n  var result = processing(domainName, {\n    processingOption: processingOption,\n    checkHyphens: checkHyphens,\n    checkBidi: checkBidi,\n    checkJoiners: checkJoiners,\n    useSTD3ASCIIRules: useSTD3ASCIIRules\n  });\n  var labels = result.string.split(\".\");\n  labels = labels.map(function (l) {\n    if (containsNonASCII(l)) {\n      try {\n        return \"xn--\" + punycode.encode(l);\n      } catch (e) {\n        result.error = true;\n      }\n    }\n\n    return l;\n  });\n\n  if (verifyDNSLength) {\n    var total = labels.join(\".\").length;\n\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n\n    for (var i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) {\n    return null;\n  }\n\n  return labels.join(\".\");\n}\n\nfunction toUnicode(domainName) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref5$checkHyphens = _ref5.checkHyphens,\n      checkHyphens = _ref5$checkHyphens === void 0 ? false : _ref5$checkHyphens,\n      _ref5$checkBidi = _ref5.checkBidi,\n      checkBidi = _ref5$checkBidi === void 0 ? false : _ref5$checkBidi,\n      _ref5$checkJoiners = _ref5.checkJoiners,\n      checkJoiners = _ref5$checkJoiners === void 0 ? false : _ref5$checkJoiners,\n      _ref5$useSTD3ASCIIRul = _ref5.useSTD3ASCIIRules,\n      useSTD3ASCIIRules = _ref5$useSTD3ASCIIRul === void 0 ? false : _ref5$useSTD3ASCIIRul,\n      _ref5$processingOptio = _ref5.processingOption,\n      processingOption = _ref5$processingOptio === void 0 ? \"nontransitional\" : _ref5$processingOptio;\n\n  var result = processing(domainName, {\n    processingOption: processingOption,\n    checkHyphens: checkHyphens,\n    checkBidi: checkBidi,\n    checkJoiners: checkJoiners,\n    useSTD3ASCIIRules: useSTD3ASCIIRules\n  });\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\n\nmodule.exports = {\n  toASCII: toASCII,\n  toUnicode: toUnicode\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/tr46/index.js"],"names":["punycode","require","regexes","mappingTable","STATUS_MAPPING","containsNonASCII","str","test","findStatus","val","useSTD3ASCIIRules","start","end","length","mid","Math","floor","target","min","Array","isArray","max","disallowed_STD3_valid","disallowed_STD3_mapped","disallowed","slice","valid","mapped","mapChars","domainName","processingOption","hasError","processed","ch","codePointAt","status","mapping","ignored","deviation","string","error","validateLabel","label","checkHyphens","checkBidi","checkJoiners","normalize","codePoints","from","startsWith","endsWith","includes","combiningMarks","last","entries","i","combiningClassVirama","next","indexOf","validZWNJ","join","rtl","bidiS1LTR","bidiS1RTL","bidiS2","bidiS3","bidiS4EN","bidiS4AN","bidiS5","bidiS6","isBidiDomain","labels","domain","map","decode","substring","err","bidiDomain","processing","options","split","isBidi","origLabel","curProcessing","validation","Object","assign","toASCII","verifyDNSLength","RangeError","result","l","encode","e","total","toUnicode","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst punycode = require(\"punycode\");\nconst regexes = require(\"./lib/regexes.js\");\nconst mappingTable = require(\"./lib/mappingTable.json\");\nconst { STATUS_MAPPING } = require(\"./lib/statusMapping.js\");\n\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/.test(str);\n}\n\nfunction findStatus(val, { useSTD3ASCIIRules }) {\n  let start = 0;\n  let end = mappingTable.length - 1;\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n\n    const target = mappingTable[mid];\n    const min = Array.isArray(target[0]) ? target[0][0] : target[0];\n    const max = Array.isArray(target[0]) ? target[0][1] : target[0];\n\n    if (min <= val && max >= val) {\n      if (useSTD3ASCIIRules &&\n          (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {\n        return [STATUS_MAPPING.disallowed, ...target.slice(2)];\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {\n        return [STATUS_MAPPING.valid, ...target.slice(2)];\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {\n        return [STATUS_MAPPING.mapped, ...target.slice(2)];\n      }\n\n      return target.slice(1);\n    } else if (min > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nfunction mapChars(domainName, { useSTD3ASCIIRules, processingOption }) {\n  let hasError = false;\n  let processed = \"\";\n\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });\n\n    switch (status) {\n      case STATUS_MAPPING.disallowed:\n        hasError = true;\n        processed += ch;\n        break;\n      case STATUS_MAPPING.ignored:\n        break;\n      case STATUS_MAPPING.mapped:\n        processed += mapping;\n        break;\n      case STATUS_MAPPING.deviation:\n        if (processingOption === \"transitional\") {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n        break;\n      case STATUS_MAPPING.valid:\n        processed += ch;\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nfunction validateLabel(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n\n  const codePoints = Array.from(label);\n\n  if (checkHyphens) {\n    if ((codePoints[2] === \"-\" && codePoints[3] === \"-\") ||\n        (label.startsWith(\"-\") || label.endsWith(\"-\"))) {\n      return false;\n    }\n  }\n\n  if (label.includes(\".\") ||\n      (codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0]))) {\n    return false;\n  }\n\n  for (const ch of codePoints) {\n    const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });\n    if ((processingOption === \"transitional\" && status !== STATUS_MAPPING.valid) ||\n        (processingOption === \"nontransitional\" &&\n         status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation)) {\n      return false;\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5892#appendix-A\n  if (checkJoiners) {\n    let last = 0;\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5893#section-2\n  if (checkBidi) {\n    let rtl;\n\n    // 1\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) ||\n          !regexes.bidiS3.test(label) ||\n          (regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label))) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) ||\n               !regexes.bidiS6.test(label)) { // 5-6\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch (err) {\n        return \"\";\n      }\n    }\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\n\nfunction processing(domainName, options) {\n  const { processingOption } = options;\n\n  // 1. Map.\n  let { string, error } = mapChars(domainName, options);\n\n  // 2. Normalize.\n  string = string.normalize(\"NFC\");\n\n  // 3. Break.\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels);\n\n  // 4. Convert/Validate.\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let curProcessing = processingOption;\n    if (label.startsWith(\"xn--\")) {\n      try {\n        label = punycode.decode(label.substring(4));\n        labels[i] = label;\n      } catch (err) {\n        error = true;\n        continue;\n      }\n      curProcessing = \"nontransitional\";\n    }\n\n    // No need to validate if we already know there is an error.\n    if (error) {\n      continue;\n    }\n    const validation = validateLabel(label, Object.assign({}, options, {\n      processingOption: curProcessing,\n      checkBidi: options.checkBidi && isBidi\n    }));\n    if (!validation) {\n      error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\n\nfunction toASCII(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false,\n  processingOption = \"nontransitional\",\n  verifyDNSLength = false\n} = {}) {\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\n  }\n\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return \"xn--\" + punycode.encode(l);\n      } catch (e) {\n        result.error = true;\n      }\n    }\n    return l;\n  });\n\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) {\n    return null;\n  }\n  return labels.join(\".\");\n}\n\nfunction toUnicode(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false,\n  processingOption = \"nontransitional\"\n} = {}) {\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\n\nmodule.exports = {\n  toASCII,\n  toUnicode\n};\n"]},"metadata":{},"sourceType":"script"}