{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar xnv = require(\"xml-name-validator\");\n\nvar attributeUtils = require(\"./attributes\");\n\nvar _require = require(\"./constants\"),\n    NAMESPACES = _require.NAMESPACES,\n    VOID_ELEMENTS = _require.VOID_ELEMENTS,\n    NODE_TYPES = _require.NODE_TYPES;\n\nvar XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nvar PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  var defaultNamespaceAttrValue = null;\n\n  for (var i = 0; i < element.attributes.length; ++i) {\n    var attr = element.attributes[i];\n\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n\n      var namespaceDefinition = attr.value;\n\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      } // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n\n\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {\n        continue;\n      }\n\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('\"') && node.systemId.includes(\"'\"))) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  var markup = \"<!DOCTYPE \".concat(node.name);\n\n  if (node.publicId !== \"\") {\n    markup += \" PUBLIC \\\"\".concat(node.publicId, \"\\\"\");\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n\n  if (node.systemId !== \"\") {\n    markup += \" \\\"\".concat(node.systemId, \"\\\"\");\n  }\n\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n\n  return \"<?\".concat(node.target, \" \").concat(node.data, \"?>\");\n}\n\nfunction serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n\n  var serializedDocument = \"\";\n\n  var _iterator = _createForOfIteratorHelper(node.childNodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {\n  var markup = \"\";\n\n  var _iterator2 = _createForOfIteratorHelper(node.childNodes),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (requireWellFormed && (node.data.includes(\"--\") || node.data.endsWith(\"-\"))) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n\n  return \"<!--\".concat(node.data, \"-->\");\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && (node.localName.includes(\":\") || !xnv.name(node.localName))) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n\n  var markup = \"<\";\n  var qualifiedName = \"\";\n  var skipEndTag = false;\n  var ignoreNamespaceDefinitionAttr = false;\n  var map = Object.assign({}, prefixMap);\n  var localPrefixesMap = Object.create(null);\n  var localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);\n  var inheritedNs = namespace;\n  var ns = node.namespaceURI;\n\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n\n    markup += qualifiedName;\n  } else {\n    var prefix = node.prefix;\n    var candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n\n      candidatePrefix = \"xmlns\";\n    }\n\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n\n      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += \"\".concat(qualifiedName, \" xmlns:\").concat(prefix, \"=\\\"\").concat(attributeUtils.serializeAttributeValue(ns, requireWellFormed), \"\\\"\");\n\n      if (localDefaultNamespace !== null) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += \"\".concat(qualifiedName, \" xmlns=\\\"\").concat(attributeUtils.serializeAttributeValue(ns, requireWellFormed), \"\\\"\");\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);\n\n  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n\n  markup += \">\";\n\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);\n  } else {\n    var _iterator3 = _createForOfIteratorHelper(node.childNodes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var child = _step3.value;\n        markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  markup += \"</\".concat(qualifiedName, \">\");\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n/**\n * @param {{prefixIndex: number}} refs\n */\n\n\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = function (root) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$requireWellForme = _ref.requireWellFormed,\n      requireWellFormed = _ref$requireWellForme === void 0 ? false : _ref$requireWellForme;\n\n  var namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};","map":{"version":3,"sources":["C:/Users/MOHAM/Desktop/Team-Finder-Client/node_modules/w3c-xmlserializer/lib/serialize.js"],"names":["xnv","require","attributeUtils","NAMESPACES","VOID_ELEMENTS","NODE_TYPES","XML_CHAR","PUBID_CHAR","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","recordNamespaceInformation","element","map","prefixMap","defaultNamespaceAttrValue","attributes","attr","namespaceURI","XMLNS","prefix","value","namespaceDefinition","XML","includes","localName","push","serializeDocumentType","node","namespace","requireWellFormed","test","publicId","Error","systemId","markup","name","serializeProcessingInstruction","target","data","serializeDocument","refs","documentElement","serializedDocument","childNodes","child","xmlSerialization","serializeDocumentFragment","serializeText","replace","serializeComment","endsWith","serializeElement","qualifiedName","skipEndTag","ignoreNamespaceDefinitionAttr","Object","assign","localPrefixesMap","create","localDefaultNamespace","inheritedNs","ns","candidatePrefix","preferredPrefixString","generatePrefix","prefixIndex","serializeAttributeValue","serializeAttributes","HTML","has","content","serializeCDATASection","nodeType","ELEMENT_NODE","DOCUMENT_NODE","COMMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","DOCUMENT_TYPE_NODE","PROCESSING_INSTRUCTION_NODE","ATTRIBUTE_NODE","CDATA_SECTION_NODE","TypeError","module","exports","root","namespacePrefixMap"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\n\nconst attributeUtils = require(\"./attributes\");\nconst { NAMESPACES, VOID_ELEMENTS, NODE_TYPES } = require(\"./constants\");\n\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n      let namespaceDefinition = attr.value;\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      }\n      // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (\n        namespaceDefinition in map &&\n        map[namespaceDefinition].includes(attr.localName)\n      ) {\n        continue;\n      }\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.systemId) ||\n      (node.systemId.includes('\"') && node.systemId.includes(\"'\")))\n  ) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  let markup = `<!DOCTYPE ${node.name}`;\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed\n) {\n  if (\n    requireWellFormed &&\n    (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n  return `<?${node.target} ${node.data}?>`;\n}\n\nfunction serializeDocument(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n  let serializedDocument = \"\";\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  let markup = \"\";\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (node.data.includes(\"--\") || node.data.endsWith(\"-\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n  return `<!--${node.data}-->`;\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (\n    requireWellFormed &&\n    (node.localName.includes(\":\") || !xnv.name(node.localName))\n  ) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(\n    node,\n    map,\n    localPrefixesMap\n  );\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n    markup += qualifiedName;\n  } else {\n    let { prefix } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n      candidatePrefix = \"xmlns\";\n    }\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n      if (\n        localDefaultNamespace !== null &&\n        localDefaultNamespace !== NAMESPACES.XML\n      ) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n      if (localDefaultNamespace !== null) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(\n    node,\n    map,\n    localPrefixesMap,\n    ignoreNamespaceDefinitionAttr,\n    requireWellFormed,\n    refs\n  );\n\n  if (\n    ns === NAMESPACES.HTML &&\n    node.childNodes.length === 0 &&\n    VOID_ELEMENTS.has(node.localName)\n  ) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n  markup += \">\";\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(\n      node.content,\n      inheritedNs,\n      map,\n      requireWellFormed,\n      refs\n    );\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(\n        child,\n        inheritedNs,\n        map,\n        requireWellFormed,\n        refs\n      );\n    }\n  }\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n\n/**\n * @param {{prefixIndex: number}} refs\n */\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = (root, { requireWellFormed = false } = {}) => {\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};\n"]},"metadata":{},"sourceType":"script"}